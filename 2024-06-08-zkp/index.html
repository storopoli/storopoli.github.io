<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zero-Knowledge Proofs | Jose Storopoli, PhD</title>
<meta name=keywords content="bitcoin,cryptography"><meta name=description content="Zero-Knowledge Proofs and the Meaning of Life Warning: This post has KaTeX and mermaid.js enabled, so if you want to view the rendered math formulas, and diagrams, you&rsquo;ll have to unfortunately enable JavaScript.
Lately, I&rsquo;ve been diving a little into the world of Zero-Knowledge Proofs. The idea is to prove that you know something without revealing what you know. More specifically, a Zero-Knowledge Proof is a cryptographic protocol that allows a prover to convince a verifier that a statement is true without revealing any information beyond the validity of the statement."><meta name=author content="Jose Storopoli"><link rel=canonical href=https://storopoli.io/2024-06-08-zkp/><link crossorigin=anonymous href=/assets/css/stylesheet.5d45b8bd1a3cf526e72959d51f1bdc688d8e97fa0df2a697a93df6bdc746feb4.css integrity="sha256-XUW4vRo89SbnKVnVHxvcaI2Ol/oN8qaXqT32vcdG/rQ=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://storopoli.io/assets/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://storopoli.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://storopoli.io/favicon-32x32.png><link rel=apple-touch-icon href=https://storopoli.io/apple-touch-icon.png><link rel=mask-icon href=https://storopoli.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://storopoli.io/2024-06-08-zkp/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js crossorigin=anonymous></script><script>mermaid.initialize({startOnLoad:!0,theme:localStorage.getItem("pref-theme")=="dark"?"dark":"default"})</script><meta property="og:title" content="Zero-Knowledge Proofs"><meta property="og:description" content="Zero-Knowledge Proofs and the Meaning of Life Warning: This post has KaTeX and mermaid.js enabled, so if you want to view the rendered math formulas, and diagrams, you&rsquo;ll have to unfortunately enable JavaScript.
Lately, I&rsquo;ve been diving a little into the world of Zero-Knowledge Proofs. The idea is to prove that you know something without revealing what you know. More specifically, a Zero-Knowledge Proof is a cryptographic protocol that allows a prover to convince a verifier that a statement is true without revealing any information beyond the validity of the statement."><meta property="og:type" content="article"><meta property="og:url" content="https://storopoli.io/2024-06-08-zkp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-08T15:48:33-03:00"><meta property="article:modified_time" content="2024-06-09T08:34:22-03:00"><meta property="og:site_name" content="Jose Storopoli, PhD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zero-Knowledge Proofs"><meta name=twitter:description content="Zero-Knowledge Proofs and the Meaning of Life Warning: This post has KaTeX and mermaid.js enabled, so if you want to view the rendered math formulas, and diagrams, you&rsquo;ll have to unfortunately enable JavaScript.
Lately, I&rsquo;ve been diving a little into the world of Zero-Knowledge Proofs. The idea is to prove that you know something without revealing what you know. More specifically, a Zero-Knowledge Proof is a cryptographic protocol that allows a prover to convince a verifier that a statement is true without revealing any information beyond the validity of the statement."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://storopoli.io/posts/"},{"@type":"ListItem","position":2,"name":"Zero-Knowledge Proofs","item":"https://storopoli.io/2024-06-08-zkp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zero-Knowledge Proofs","name":"Zero-Knowledge Proofs","description":"Zero-Knowledge Proofs and the Meaning of Life Warning: This post has KaTeX and mermaid.js enabled, so if you want to view the rendered math formulas, and diagrams, you\u0026rsquo;ll have to unfortunately enable JavaScript.\nLately, I\u0026rsquo;ve been diving a little into the world of Zero-Knowledge Proofs. The idea is to prove that you know something without revealing what you know. More specifically, a Zero-Knowledge Proof is a cryptographic protocol that allows a prover to convince a verifier that a statement is true without revealing any information beyond the validity of the statement.","keywords":["bitcoin","cryptography"],"articleBody":" Zero-Knowledge Proofs and the Meaning of Life Warning: This post has KaTeX and mermaid.js enabled, so if you want to view the rendered math formulas, and diagrams, you’ll have to unfortunately enable JavaScript.\nLately, I’ve been diving a little into the world of Zero-Knowledge Proofs. The idea is to prove that you know something without revealing what you know. More specifically, a Zero-Knowledge Proof is a cryptographic protocol that allows a prover to convince a verifier that a statement is true without revealing any information beyond the validity of the statement. In essence, by the end of the protocol, the verifier is convinced that the prover knows the secret, and the verifier hasn’t learned anything (zero-knowledge) about the secret.\nZero-Knowledge Proofs (ZKPs) are kinda hot right now, since a lot of new Bitcoin innovations are being built on top of them. It allows for a higher level of privacy and potential scalability improvements in the Bitcoin network.\nZero-knowledge proofs are advantageous in a myriad of application, including (refer to Petkus19):\nProving statement on private data:\nPerson $A$ has more than $X$ in his bank account In the last year, a bank did not transact with an entity $Y$ Matching DNA without revealing full DNA One has a credit score higher than $Z$ Anonymous authorization:\nProving that requester $R$ has right to access web-site’s restricted area without revealing its identity (e.g., login, password) Prove that one is from the list of allowed countries/states without revealing from which one exactly Prove that one owns a monthly pass to a subway/metro without revealing card’s id Anonymous payments:\nPayment with full detachment from any kind of identity Paying taxes without revealing one’s earnings Outsourcing computation:\nOutsource an expensive computation and validate that the result is correct without redoing the execution; it opens up a category of trustless computing Changing a blockchain model from everyone computes the same to one party computes and everyone verifies The idea behind this post is to give a general overview of Zero-Knowledge Proofs, while providing further resources, especially which papers to read, to dive deeper into the subject. As always, I’ll try to keep it simple and intuitive. However, as you might guess, the subject is quite complex, and I’ll try to simplify it as much as possible; but some mathematical background is necessary.\nWhat are ZKPs? Let’s formalize the concept of Zero-Knowledge Proofs. A formal definition of zero-knowledge has to use some computational model, and without loss of generality, we can use the Turing Machine model. So let’s create three Turing machines:\n$P$ (the prover), $V$ (the verifier), and $S$ (the simulator). Let’s also spicy things up a bit and introduce an adversary $A$, and assume that it is also a Turing machine. The secret we want to prove knowledge without revealing is $x$.\nThe prover $P$ wants to prove to the verifier $V$ that it knows the secret $x$. They both share a common simulator $S$. The adversary $A$ is trying to fool the verifier $V$ into believing that it knows the secret $x$, without actually knowing it.\nThe prover $P$ generates a proof $\\pi = P(S, x)$, and sends it to the verifier $V$. The verifier $V$ then checks the proof $\\pi$, and decides whether to accept or reject it.\nThe tuple $(P, V, S)$ is a Zero-Knowledge Proof if the following properties hold:\nCompleteness: If the statement is true, the verifier will accept the proof.\n$$ \\Pr\\big[V(S, \\pi) = \\text{accept} \\big] = 1. $$\nHere $\\Pr\\big[V(S, \\pi) = \\text{accept} \\big]$ denotes the probability that the verifier accepts the proof given a simulator $S$ and a proof $\\pi$.\nSoundness: If the statement is true, no cheating prover can convince an honest verifier that it is true, except with some negligible probability 1.\n$$ \\forall A, \\forall x, \\forall \\pi: \\Pr\\big[V(A, S, \\pi) = \\text{accept} \\big] \u003c \\text{negligible}. $$\nHere $\\Pr\\big[V(A, S, \\pi) = \\text{accept} \\big]$ denotes the probability that the verifier accepts the proof given an adversary $A$, a simulator $S$, and a proof $\\pi$.\nZero-Knowledge: If the statement is true, the verifier learns nothing about the secret $x$. A proof is zero-knowledge if there exists a simulator $S$ that can simulate the verifier’s view without knowing the secret $x$.\n$$ \\forall x: \\text{View}_V\\big[P(x) \\leftrightarrow V(\\pi)\\big] = S(x, \\pi). $$\nHere $\\text{View}_V$ is the view of the verifier $V$, and $\\leftrightarrow$ denotes the interaction between the prover and the verifier.\nIf you come up from a scheme that satisfies these properties, congratulations, you have a Zero-Knowledge Proof scheme and you can name it whatever you want, just like a Pokemon!\nZKPs Taxonomy We can classify Zero-Knowledge Proofs into two broad categories:\nInteractive Zero-Knowledge Proofs: In this case, the prover and the verifier interact multiple times. The prover sends a proof to the verifier, and the verifier sends a challenge to the prover, and this interaction continues until the verifier is convinced. The Fiat-Shamir Heuristic can transform an interactive ZKP into a non-interactive ZKP.\nNon-Interactive Zero-Knowledge Proofs: In this case, the prover sends a proof to the verifier, and the verifier accepts or rejects the proof. No further interaction is needed.\nAdditionally, the setup of the simulator $S$ with respect to the data it uses can be further classified into three categories. Generally speaking, the data used by $S$ is some random bits. In trusted setups, if the data is compromised, the security of the proof is also compromised. In other words, anyone with the hold of the data can prove anything to anyone. This is bad, and we want to avoid it.\nTrusted Setup: $S$ uses data that must be kept secret. Trusted but Universal Setup: $S$ uses data that must be kept private, but it only uses for the initial setup. Future proofs can be verified without the need for the initial data, and can be considered transparent. Transparent Setup: $S$ uses no data at all. This is the best setup, as it doesn’t require any data to be used by $S$. Some of the most popular Zero-Knowledge Proof systems are:\nzk-SNARKs: Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. This is a non-interactive ZKP system with a trusted setup. Bulletproofs: A non-interactive ZKP system with a transparent setup. zk-STARKs: Zero-Knowledge Scalable Transparent Argument of Knowledge. This is a non-interactive ZKP system with a transparent setup, with an additional property of being (plausibly) post-quantum secure. zk-SNARKs zk-SNARKs are the most popular Zero-Knowledge Proof system. They are used in the Zcash protocol, and the defunct Tornado Cash smart contract. Ethereum also uses zk-SNARKs in its Layer 2 scaling solution, the zk-Rollups. BitVM also uses a SNARK-based VM to run smart contracts on top of Bitcoin.\nLet’s go over the concepts behind zk-SNARKs2.\nThe first idea: Proving Knowledge of a Polynomial First some polynomial primer. A polynomial $f(x)$ is a function that can be written as:\n$$ f(x) = c_d x^d + \\ldots + c_1 x^1 + c_0 x^0 $$\nwhere $c_d, \\ldots, c_1, c_0$ are the coefficients of the polynomial, and $d$ is the degree of the polynomial.\nNow, the Fundamental Theorem of Algebra states that a polynomial of degree $d$ can have at most $d$ (real-valued-only) roots3.\nThis can be extended to the concept that two non-equal polynomials of degree $d$ can have at most $d$ points of intersection.\nThe idea of proving knowledge of a polynomial is to show that you know the polynomial, without revealing the polynomial itself.\nThis simple protocol can be done in four steps, note that both the prover and the verifier have knowledge of the polynomial:\nVerifier chooses a random value for $x$ and evaluates his polynomial locally Verifier gives $x$ to the prover and asks to evaluate the polynomial in question Prover evaluates his polynomial at $x$ and gives the result to the verifier Verifier checks if the local result is equal to the prover’s result, and if so then the statement is proven with a high confidence How much is “high confidence”? Suppose that the verifier chooses an $x$ at random from a set of $2^{256}$ values, that is a 256-bit number. According to Wolfram Alpha, the decimal approximation is $\\approx 1.16 \\times 10^{77}$. This is almost the number of atoms in the observable universe! The number of points where evaluations are different is $10^{77} - d$, where $d$ is the degree of the polynomial. Therefore, we can assume with overwhelming probability that the prover knows the polynomial. This is due to the fact that an adversary has $\\frac{d}{10^{77}}$ chance of guessing the polynomial4, which we can safely consider negligible1.\nThe second idea: Proving Knowledge of a Polynomial without Revealing the Polynomial The protocol above has some implications, mainly that the protocol works only for a certain polynomial, and the verifier has to know the polynomial in advance. Which is not practical at all since we want to prove knowledge of a secret without revealing the secret itself.\nWe can do better, we can use the fact, also stated in the Fundamental Theorem of Algebra, that any polynomial can be factored into linear polynomials, i.e. a set of degree-1 polynomials representing a line. We can represent any valid polynomial as a product of its linear-polynomial factors:\n$$ (x - a_0) (x - a_1) \\ldots (x - a_d) = 0 $$\nwhere $a_0, \\ldots, a_{d}$ are the roots of the polynomial. If you wanna prove knowledge of a polynomial, it is just a matter of proving knowledge of its roots. But how do we do that without disclosing the polynomial itself? This can be accomplished by proving that a polynomial $p(x)$ is the multiplication of the factors $t(x) = (x - a_0) \\ldots (x - a_d)$, called the target polynomial, and some arbitrary polynomial $h(x)$, called the residual polynomial:\n$$ p(x) = t(x) \\cdot h(x). $$\nThe prover can show that exists some polynomial $h(x)$ such that $p(x)$ can be made equal to $t(x)$. You can find $h(x)$ by simply dividing $p(x)$ by $t(x)$:\n$$ h(x) = \\frac{p(x)}{t(x)}. $$\nNow we can create a protocol that can work for any polynomial $p(x)$ with only three steps:\nVerifier samples a random value $r$, calculates $t = t(r)$ and gives $r$ to the prover Prover calculates $h(x) = \\frac{p(x)}{t(x)}$ and evaluates $p = p(r)$ and $h = h(r)$; the resulting values $p$, $h$ are provided to the verifier Verifier then checks that $p = t \\cdot h$, if so those polynomials are equal, meaning that $p(x)$ has $t(x)$ as a cofactor. Note that the verifier has no clue about the polynomial $p(x)$, and can be convinced that the prover knows the polynomial $p(x)$.\nFor example, let’s consider two polynomials $p(x)$ and $t(x)$ of degree $3$:\n$p(x) = x^3 - 3x^2 + 2x$ $t(x) = (x - 1) (x - 2)$ An example protocol interaction in this case could be:\nVerifier samples a random value $23$, calculates $t = t(23) = (23 − 1)(23 − 2) = 462$ and gives $23$ to the prover Prover calculates $h(x) = \\frac{p(x)}{t(x)} = x$, evaluates $p = p(23) = 10626$ and $h = h(23) = 23$ and provides $p$, $h$ to the verifier Verifier then checks that $p = t \\cdot h$, i.e. $10626 = 462 \\cdot 23$, which is true, and therefore the statement is proven Great! We can prove stuff without revealing the stuff itself! Noice! We know only need to find a trick to represent any sort of computation as a polynomial.\nThe third idea: Representing Computations as Polynomials We can represent any computation as a polynomial by using Arithmetic Circuits. An arithmetic circuit is a directed acyclic graph (DAG) where:\nEvery indegree5-zero node is an input gate that represents a variable $x_i$ Every node with indegree $\u003e1$ is either: an addition gate, $+$, that represents the sum of its children a multiplication gate, $\\times$, that represents the product of its children Here’s an example of an arithmetic circuit that represents the polynomial $p(x_1, x_2) = x_2^3 + x_1 x_2^2 + x_2^2 + x_1 x_2$:\n--- title: Arithmetic Circuit for p(x) --- graph BT X1(x₁) --\u003e Plus1(+) X2(X₂) --\u003e Plus1 X2 --\u003e Plus2(+) One(1) --\u003e Plus2 Plus1 --\u003e Times(⨉) Plus2 --\u003e Times X2 --\u003e Times In the circuit above, the input gates compute (from left to right) $x_{1},x_{2}$ and $1$, the sum gates compute $x_{1}+x_{2}$ and $x_{2}+1$, and the product gate computes $(x_{1}+x_{2})x_{2}(x_{2}+1)$ which evaluates to $x_{2}^{3}+x_{1}x_{2}^{2}+x_{2}^{2}+x_{1}x_{2}$.\nThe idea is to prove that the output of the circuit is equal to some target polynomial $t(x)$. This can be done by proving that the output of the circuit is equal to the target polynomial $t(x)$ multiplied by some arbitrary polynomial $h(x)$, as we did in the previous section.\nRemarks This is a very high-level overview of Zero-Knowledge Proofs. The subject is quite complex and requires a lot of mathematical background. I tried to simplify it as much as possible, to give a general intuition of how Zero-Knowledge Proofs work. Please check the resources below for more in-depth information.\nResources We have tons of papers on the subject. Here are some selected few.\nThe whole idea of ZKPs as discussed above in three properties (Completeness, Soundness, and Zero-Knowledge) was first conceived by [SMR85]. Later [Kil92] showed that some of the properties’ assumptions can be relaxed, more specifically using computational soundness instead of statistical soundness. [Mic94] applied the Fiat-Shamir Heuristic to [Kil92]’s contributions to show that you can create any non-interactive ZKP system into a non-interactive ZKP system using the Random Oracle Model.\nGoing to the zk-SNARKs side, the term was introduced by [Bit11] and the first protocol, the Pinocchio protocol, was introduced by [Gen12] and [Par13]. The Bulletproofs protocol was introduced by [Bunz18], followed by the Bulletproofs++ protocol by [Eagen24].\nzk-STARKs were introduced by [Ben-Sasson19].\nFinally, if you want an intuitive but very comprehensive explanation of zk-SNARKs, then you should read [Petkus19].\nThe following video from YouTube is from the Blockchain Web3 MOOC from Berkeley University. It provides a good introduction to Zero-Knowledge Proofs, while being quite accessible to beginners.\nThis video from YouTube explains the math behind the Arithmetic Circuits and how to encode them as polynomials. I can’t embed the video here, since the video owner has disabled embedding.\nLicense This post is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nA function $f$ is negligible if for every polynomial $p$, there exists an $N$ such that for all $n \u003e N$, $$ f(n) \u003c \\frac{1}{p(n)}. $$ If you want to learn more about negligible functions, read Chapter 3, Section 3.1 of the book Introduction to Modern Cryptography by Katz \u0026 Lindell. ↩︎ ↩︎\nmost of this section is based on Petkus19. ↩︎\nthe “at most” is because we are talking about real-valued-only roots. If we consider complex roots, then a polynomial of degree $d$ has exactly $d$ roots. ↩︎\nthe Birthday paradox states that any collision resistance scheme has a probability of $\\frac{1}{2}$ of collision, hence we take the square root of the number of possible values. So, the security of the polynomial proof is $\\sqrt{10^{77}} = 10^{38.5}$, which is still a huge number. ↩︎\nthe number of edges entering a node ↩︎\n","wordCount":"2504","inLanguage":"en","datePublished":"2024-06-08T15:48:33-03:00","dateModified":"2024-06-09T08:34:22-03:00","author":{"@type":"Person","name":"Jose Storopoli"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://storopoli.io/2024-06-08-zkp/"},"publisher":{"@type":"Organization","name":"Jose Storopoli, PhD","logo":{"@type":"ImageObject","url":"https://storopoli.io/assets/favicon.svg"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://storopoli.io/ accesskey=h title="Jose Storopoli, PhD (Alt + H)">Jose Storopoli, PhD</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://storopoli.io/about/ title=About><span>About</span></a></li><li><a href=https://storopoli.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://storopoli.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://storopoli.io/>Home</a>&nbsp;»&nbsp;<a href=https://storopoli.io/posts/>Blog</a></div><h1 class="post-title entry-hint-parent">Zero-Knowledge Proofs</h1><div class=post-meta><span title='2024-06-08 15:48:33 -0300 -0300'>June 8, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Jose Storopoli&nbsp;|&nbsp;<a href=https://github.com/storopoli/storopoli.github.io/blob/main/content/posts/2024-06-08-zkp/index.md rel="noopener noreferrer">Source code</a></div><div class=post-meta><span title="2024-06-09 08:34:22 -0300 -0300"><i>Last updated on June 9, 2024</i></span></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-are-zkps aria-label="What are ZKPs?">What are ZKPs?</a></li><li><a href=#zkps-taxonomy aria-label="ZKPs Taxonomy">ZKPs Taxonomy</a></li><li><a href=#zk-snarks aria-label=zk-SNARKs>zk-SNARKs</a><ul><li><a href=#the-first-idea-proving-knowledge-of-a-polynomial aria-label="The first idea: Proving Knowledge of a Polynomial">The first idea: Proving Knowledge of a Polynomial</a></li><li><a href=#the-second-idea-proving-knowledge-of-a-polynomial-without-revealing-the-polynomial aria-label="The second idea: Proving Knowledge of a Polynomial without Revealing the Polynomial">The second idea: Proving Knowledge of a Polynomial without Revealing the Polynomial</a></li><li><a href=#the-third-idea-representing-computations-as-polynomials aria-label="The third idea: Representing Computations as Polynomials">The third idea: Representing Computations as Polynomials</a></li></ul></li><li><a href=#remarks aria-label=Remarks>Remarks</a></li><li><a href=#resources aria-label=Resources>Resources</a></li><li><a href=#license aria-label=License>License</a></li></ul></div></details></div><div class=post-content><figure><img loading=lazy src=zkp_meme.jpg#center alt="Zero-Knowledge Proofs and the Meaning of Life" width=500><figcaption>Zero-Knowledge Proofs and the Meaning of Life</figcaption></figure><blockquote><p>Warning: This post has <a href=https://katex.org/>KaTeX</a>
and <a href=https://mermaid.js.org><code>mermaid.js</code></a> enabled,
so if you want to view the rendered math formulas,
and diagrams,
you&rsquo;ll have to unfortunately enable JavaScript.</p></blockquote><p>Lately, I&rsquo;ve been diving a little into the world of <strong>Zero-Knowledge Proofs</strong>.
The idea is to prove that you know something without revealing what you know.
More specifically, a <strong>Zero-Knowledge Proof</strong> is a cryptographic protocol that allows
a <strong>prover</strong> to convince a <strong>verifier</strong> that a statement is true without revealing
any information beyond the validity of the statement.
In essence, by the end of the protocol, the verifier is convinced that the prover knows the secret,
and the <strong>verifier hasn&rsquo;t learned anything (zero-knowledge) about the secret</strong>.</p><p><strong>Zero-Knowledge Proofs</strong> (ZKPs) are kinda hot right now,
since a lot of new Bitcoin innovations are being built on top of them.
It allows for a higher level of privacy and potential scalability improvements
in the Bitcoin network.</p><p>Zero-knowledge proofs are advantageous in a myriad of application,
including (refer to <a href=https://arxiv.org/abs/1906.07221 title="Petkus, M. (2019). Why and How zk-SNARK works. arXiv preprint 1906.07221.">Petkus19</a>):</p><ul><li><p><strong>Proving statement on private data</strong>:</p><ul><li>Person $A$ has more than $X$ in his bank account</li><li>In the last year, a bank did not transact with an entity $Y$</li><li>Matching DNA without revealing full DNA</li><li>One has a credit score higher than $Z$</li></ul></li><li><p><strong>Anonymous authorization</strong>:</p><ul><li>Proving that requester $R$ has right to access web-site&rsquo;s restricted area without revealing its identity (e.g., login, password)</li><li>Prove that one is from the list of allowed countries/states without revealing from which one exactly</li><li>Prove that one owns a monthly pass to a subway/metro without revealing card&rsquo;s id</li></ul></li><li><p><strong>Anonymous payments</strong>:</p><ul><li>Payment with full detachment from any kind of identity</li><li>Paying taxes without revealing one&rsquo;s earnings</li></ul></li><li><p><strong>Outsourcing computation</strong>:</p><ul><li>Outsource an expensive computation and validate that the result is correct without redoing the execution;
it opens up a category of trustless computing</li><li>Changing a blockchain model from everyone computes the same to one party computes and everyone verifies</li></ul></li></ul><p>The idea behind this post is to give a general overview of Zero-Knowledge Proofs,
while providing further resources,
especially which papers to read,
to dive deeper into the subject.
As always, I&rsquo;ll try to keep it simple and intuitive.
However, as you might guess, the subject is quite complex,
and I&rsquo;ll try to simplify it as much as possible;
but some mathematical background is necessary.</p><h2 id=what-are-zkps>What are ZKPs?<a hidden class=anchor aria-hidden=true href=#what-are-zkps>#</a></h2><p>Let&rsquo;s formalize the concept of <strong>Zero-Knowledge Proofs</strong>.
A formal definition of zero-knowledge has to use some computational model,
and without loss of generality,
we can use the <a href=https://en.wikipedia.org/wiki/Turing_machine>Turing Machine</a>
model.
So let&rsquo;s create three Turing machines:</p><ul><li>$P$ (the <strong>prover</strong>),</li><li>$V$ (the <strong>verifier</strong>),</li><li>and $S$ (the <strong>simulator</strong>).</li></ul><p>Let&rsquo;s also spicy things up a bit and introduce an <strong>adversary</strong> $A$,
and assume that it is also a Turing machine.
<strong>The secret we want to prove knowledge without revealing is $x$</strong>.</p><p>The prover $P$ wants to prove to the verifier $V$ that it knows the secret $x$.
They both share a common simulator $S$.
The adversary $A$ is trying to fool the verifier $V$ into believing that it knows the secret $x$,
without actually knowing it.</p><p>The prover $P$ generates a proof $\pi = P(S, x)$,
and sends it to the verifier $V$.
The verifier $V$ then checks the proof $\pi$,
and decides whether to accept or reject it.</p><p>The tuple $(P, V, S)$ is a <strong>Zero-Knowledge Proof</strong> if the following properties hold:</p><ol><li><p><strong>Completeness</strong>: If the statement is true, the verifier will accept the proof.</p><p>$$ \Pr\big[V(S, \pi) = \text{accept} \big] = 1. $$</p><p>Here $\Pr\big[V(S, \pi) = \text{accept} \big]$ denotes the probability that the verifier accepts the proof given a simulator $S$ and a proof $\pi$.</p></li><li><p><strong>Soundness</strong>: If the statement is true, no cheating prover can convince an honest verifier that it is true,
except with some negligible probability <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>$$ \forall A, \forall x, \forall \pi: \Pr\big[V(A, S, \pi) = \text{accept} \big] &lt; \text{negligible}. $$</p><p>Here $\Pr\big[V(A, S, \pi) = \text{accept} \big]$ denotes the probability that the verifier accepts the proof given an adversary $A$, a simulator $S$, and a proof $\pi$.</p></li><li><p><strong>Zero-Knowledge</strong>: If the statement is true, the verifier learns nothing about the secret $x$.
A proof is zero-knowledge if there exists a simulator $S$ that can simulate the verifier&rsquo;s view
without knowing the secret $x$.</p><p>$$ \forall x: \text{View}_V\big[P(x) \leftrightarrow V(\pi)\big] = S(x, \pi). $$</p><p>Here $\text{View}_V$ is the view of the verifier $V$,
and $\leftrightarrow$ denotes the interaction between the prover and the verifier.</p></li></ol><p>If you come up from a scheme that satisfies these properties,
congratulations, you have a <strong>Zero-Knowledge Proof</strong> scheme
and you can name it whatever you want,
just like a Pokemon!</p><h2 id=zkps-taxonomy>ZKPs Taxonomy<a hidden class=anchor aria-hidden=true href=#zkps-taxonomy>#</a></h2><p>We can classify <strong>Zero-Knowledge Proofs</strong> into two broad categories:</p><ol><li><p><strong>Interactive Zero-Knowledge Proofs</strong>: In this case, the prover and the verifier interact multiple times.
The prover sends a proof to the verifier,
and the verifier sends a challenge to the prover,
and this interaction continues until the verifier is convinced.
The Fiat-Shamir Heuristic can transform an interactive ZKP into a non-interactive ZKP.</p></li><li><p><strong>Non-Interactive Zero-Knowledge Proofs</strong>: In this case, the prover sends a proof to the verifier,
and the verifier accepts or rejects the proof.
No further interaction is needed.</p></li></ol><p>Additionally,
the setup of the <strong>simulator $S$ with respect to the data it uses</strong>
can be further classified into three categories.
Generally speaking, the data used by $S$ is some random bits.
In trusted setups, if the data is compromised,
the security of the proof is also compromised.
In other words, anyone with the hold of the data can prove anything to anyone.
This is bad, and we want to avoid it.</p><ol><li><strong>Trusted Setup</strong>: $S$ uses data that must be kept secret.</li><li><strong>Trusted but Universal Setup</strong>: $S$ uses data that must be kept private,
but it only uses for the initial setup.
Future proofs can be verified without the need for the initial data,
and can be considered transparent.</li><li><strong>Transparent Setup</strong>: $S$ uses no data at all.
This is the best setup, as it doesn&rsquo;t require any data to be used by $S$.</li></ol><p>Some of the most popular Zero-Knowledge Proof systems are:</p><ul><li><strong>zk-SNARKs</strong>: Zero-Knowledge Succinct Non-Interactive Argument of Knowledge.
This is a non-interactive ZKP system with a trusted setup.</li><li><strong>Bulletproofs</strong>: A non-interactive ZKP system with a transparent setup.</li><li><strong>zk-STARKs</strong>: Zero-Knowledge Scalable Transparent Argument of Knowledge.
This is a non-interactive ZKP system with a transparent setup,
with an additional property of being (plausibly) post-quantum secure.</li></ul><h2 id=zk-snarks>zk-SNARKs<a hidden class=anchor aria-hidden=true href=#zk-snarks>#</a></h2><p><strong>zk-SNARKs</strong> are the most popular Zero-Knowledge Proof system.
They are used in the Zcash protocol,
and the defunct Tornado Cash smart contract.
Ethereum also uses zk-SNARKs in its Layer 2 scaling solution,
the zk-Rollups.
<a href=https://bitvm.org/>BitVM</a> also uses a SNARK-based VM to run smart contracts
on top of Bitcoin.</p><p>Let&rsquo;s go over the concepts behind zk-SNARKs<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h3 id=the-first-idea-proving-knowledge-of-a-polynomial>The first idea: Proving Knowledge of a Polynomial<a hidden class=anchor aria-hidden=true href=#the-first-idea-proving-knowledge-of-a-polynomial>#</a></h3><p>First some polynomial primer.
<strong>A polynomial $f(x)$ is a function that can be written as</strong>:</p><p>$$ f(x) = c_d x^d + \ldots + c_1 x^1 + c_0 x^0 $$</p><p>where $c_d, \ldots, c_1, c_0$ are the coefficients of the polynomial,
and $d$ is the degree of the polynomial.</p><p>Now, the <a href=https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra>Fundamental Theorem of Algebra</a> states that
<strong>a polynomial of degree $d$ can have at most $d$ (real-valued-only) roots<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></strong>.</p><p>This can be extended to the concept that <strong>two non-equal polynomials of degree $d$ can have at most $d$ points of intersection</strong>.</p><p>The idea of proving knowledge of a polynomial is to show that you know the polynomial,
without revealing the polynomial itself.</p><p>This simple protocol can be done in four steps,
note that both the prover and the verifier have knowledge of the polynomial:</p><ol><li>Verifier chooses a random value for $x$ and evaluates his polynomial locally</li><li>Verifier gives $x$ to the prover and asks to evaluate the polynomial in question</li><li>Prover evaluates his polynomial at $x$ and gives the result to the verifier</li><li>Verifier checks if the local result is equal to the prover&rsquo;s result,
and if so then the statement is proven with a high confidence</li></ol><p>How much is &ldquo;high confidence&rdquo;?
Suppose that the verifier chooses an $x$ at random from a set of $2^{256}$ values,
that is a 256-bit number.
According to <a href="https://www.wolframalpha.com/input?i2d=true&amp;i=Power%5B2%2C256%5D">Wolfram Alpha</a>,
the decimal approximation is $\approx 1.16 \times 10^{77}$.
This is almost the <a href=https://en.wikipedia.org/wiki/Observable_universe#Matter_content%E2%80%94number_of_atoms>number of atoms in the observable universe</a>!
The number of points where evaluations are different is $10^{77} - d$,
where $d$ is the degree of the polynomial.
Therefore, we can assume with overwhelming probability that the prover knows the polynomial.
This is due to the fact that an adversary has $\frac{d}{10^{77}}$ chance of guessing the polynomial<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>,
which we can safely consider negligible<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><h3 id=the-second-idea-proving-knowledge-of-a-polynomial-without-revealing-the-polynomial>The second idea: Proving Knowledge of a Polynomial without Revealing the Polynomial<a hidden class=anchor aria-hidden=true href=#the-second-idea-proving-knowledge-of-a-polynomial-without-revealing-the-polynomial>#</a></h3><p>The protocol above has some implications,
mainly that the protocol works only for a certain polynomial,
and the verifier has to know the polynomial in advance.
Which is not practical at all since we want to prove knowledge
of a secret without revealing the secret itself.</p><p>We can do better, we can use the fact,
also stated in the <a href=https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra>Fundamental Theorem of Algebra</a>,
that any polynomial can be factored into linear polynomials,
i.e. a set of degree-1 polynomials representing a line.
We can represent any valid polynomial as a product of its linear-polynomial factors:</p><p>$$ (x - a_0) (x - a_1) \ldots (x - a_d) = 0 $$</p><p>where $a_0, \ldots, a_{d}$ are the roots of the polynomial.
If you wanna prove knowledge of a polynomial, it is just a matter of proving knowledge of its roots.
But how do we do that without disclosing the polynomial itself?
This can be accomplished by proving that a polynomial $p(x)$ is the multiplication
of the factors $t(x) = (x - a_0) \ldots (x - a_d)$, called the <strong>target polynomial</strong>,
and some arbitrary polynomial $h(x)$, called the <strong>residual polynomial</strong>:</p><p>$$ p(x) = t(x) \cdot h(x). $$</p><p>The prover can show that exists some polynomial $h(x)$ such that
$p(x)$ can be made equal to $t(x)$.
You can find $h(x)$ by simply dividing $p(x)$ by $t(x)$:</p><p>$$ h(x) = \frac{p(x)}{t(x)}. $$</p><p>Now we can create a protocol that can work for any polynomial $p(x)$
with only three steps:</p><ol><li>Verifier samples a random value $r$, calculates $t = t(r)$ and gives $r$ to the
prover</li><li>Prover calculates $h(x) = \frac{p(x)}{t(x)}$ and evaluates $p = p(r)$ and $h = h(r)$;
the resulting values $p$, $h$ are provided to the verifier</li><li>Verifier then checks that $p = t \cdot h$, if so those polynomials are equal,
meaning that $p(x)$ has $t(x)$ as a cofactor.</li></ol><p>Note that the verifier has no clue about the polynomial $p(x)$,
and can be convinced that the prover knows the polynomial $p(x)$.</p><p>For example, let&rsquo;s consider two polynomials $p(x)$ and $t(x)$ of degree $3$:</p><ul><li>$p(x) = x^3 - 3x^2 + 2x$</li><li>$t(x) = (x - 1) (x - 2)$</li></ul><p>An example protocol interaction in this case could be:</p><ol><li>Verifier samples a random value $23$, calculates $t = t(23) = (23 − 1)(23 − 2) = 462$ and
gives $23$ to the prover</li><li>Prover calculates $h(x) = \frac{p(x)}{t(x)} = x$, evaluates $p = p(23) = 10626$ and $h = h(23) = 23$
and provides $p$, $h$ to the verifier</li><li>Verifier then checks that $p = t \cdot h$, i.e. $10626 = 462 \cdot 23$,
which is true, and therefore the statement is proven</li></ol><p>Great! We can prove stuff without revealing the stuff itself!
Noice!
We know only need to find a trick to represent
any sort of computation as a polynomial.</p><h3 id=the-third-idea-representing-computations-as-polynomials>The third idea: Representing Computations as Polynomials<a hidden class=anchor aria-hidden=true href=#the-third-idea-representing-computations-as-polynomials>#</a></h3><p>We can <strong>represent any computation as a polynomial by using <a href=https://en.wikipedia.org/wiki/Arithmetic_circuit>Arithmetic Circuits</a></strong>.
An arithmetic circuit is a directed acyclic graph (DAG) where:</p><ul><li>Every indegree<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>-zero node is an input gate that represents a variable $x_i$</li><li>Every node with indegree $>1$ is either:<ul><li>an addition gate, $+$, that represents the sum of its children</li><li>a multiplication gate, $\times$, that represents the product of its children</li></ul></li></ul><p>Here&rsquo;s an example of an arithmetic circuit that represents the polynomial $p(x_1, x_2) = x_2^3 + x_1 x_2^2 + x_2^2 + x_1 x_2$:</p><div class=mermaid style=text-align:center>---
title: Arithmetic Circuit for p(x)
---
graph BT
X1(x₁) --> Plus1(+)
X2(X₂) --> Plus1
X2 --> Plus2(+)
One(1) --> Plus2
Plus1 --> Times(⨉)
Plus2 --> Times
X2 --> Times</div><p>In the circuit above, the input gates compute (from left to right)
$x_{1},x_{2}$ and $1$,
the sum gates compute $x_{1}+x_{2}$
and $x_{2}+1$,
and the product gate computes $(x_{1}+x_{2})x_{2}(x_{2}+1)$
which evaluates to $x_{2}^{3}+x_{1}x_{2}^{2}+x_{2}^{2}+x_{1}x_{2}$.</p><p>The idea is to prove that the output of the circuit is equal to some target polynomial $t(x)$.
This can be done by proving that the output of the circuit is equal to the target polynomial $t(x)$
multiplied by some arbitrary polynomial $h(x)$,
as we did in the previous section.</p><h2 id=remarks>Remarks<a hidden class=anchor aria-hidden=true href=#remarks>#</a></h2><p>This is a very high-level overview of Zero-Knowledge Proofs.
The subject is quite complex and requires a lot of mathematical background.
I tried to simplify it as much as possible,
to give a general intuition of how Zero-Knowledge Proofs work.
Please check the resources below for more in-depth information.</p><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><p>We have tons of papers on the subject.
Here are some selected few.</p><p>The whole idea of ZKPs as discussed above in three properties
(Completeness, Soundness, and Zero-Knowledge)
was first conceived by [<a href=https://epubs.siam.org/doi/10.1137/0218012 title="Goldwasser, S., Micali, S., & Rackoff, C. (1985). The knowledge complexity of interactive proof systems. SIAM Journal on computing, 18(1), 186-208.">SMR85</a>].
Later [<a href=https://dl.acm.org/doi/abs/10.1145/129712.129782 title="Kilian, J. (1992). A note on efficient zero-knowledge proofs and arguments (extended abstract). In Proceedings of the twenty-fourth annual ACM symposium on Theory of computing (pp. 723-732).">Kil92</a>] showed that some of the properties&rsquo; assumptions can be relaxed,
more specifically using computational soundness instead of statistical soundness.
[<a href=https://ieeexplore.ieee.org/abstract/document/365746/ title="Micali, S. (1994). CS proofs (extended abstract). In Proceedings 35th Annual Symposium on Foundations of Computer Science (pp. 436-445).">Mic94</a>] applied the <a href=https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic>Fiat-Shamir Heuristic</a>
to [<a href=https://dl.acm.org/doi/abs/10.1145/129712.129782 title="Kilian, J. (1992). A note on efficient zero-knowledge proofs and arguments (extended abstract). In Proceedings of the twenty-fourth annual ACM symposium on Theory of computing (pp. 723-732).">Kil92</a>]&rsquo;s contributions to show that you can create any non-interactive ZKP system into
a non-interactive ZKP system using the <a href=https://en.wikipedia.org/wiki/Random_oracle_model>Random Oracle Model</a>.</p><p>Going to the zk-SNARKs side,
the term was introduced by [<a href=https://eprint.iacr.org/2011/443 title="Bitansky, N., Canetti, R., & Goldwasser, S. (2011). From Extractable Collision Resistance to Succinct Non-Interactive Arguments of Knowledge, and Back Again. In Proceedings of the 3rd innovations in theoretical computer science conference (pp. 326-349).">Bit11</a>]
and the first protocol, the Pinocchio protocol,
was introduced by [<a href=https://eprint.iacr.org/2012/215 title="Gennaro, R., Gentry, C., Parno, B., & Raykova, M. (2013). Quadratic span programs and succinct NIZKs without PCPs. In Advances in Cryptology–EUROCRYPT 2013: 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings 32 (pp. 626-645).">Gen12</a>] and [<a href=https://eprint.iacr.org/2013/279 title="Parno, B., Gentry, C., Howell, J., & Raykova, M. (2013). Pinocchio: Nearly practical verifiable computation. In Proceedings of the 2013 IEEE Symposium on Security and Privacy (SP) (pp. 238-252).">Par13</a>].
The Bulletproofs protocol was introduced by [<a href=https://ieeexplore.ieee.org/document/8418611 title="Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., & Maxwell, G. (2018). Bulletproofs: Short Proofs for Confidential Transactions and More. In Proceedings of the 2018 IEEE Symposium on Security and Privacy (SP) (pp. 315-334).">Bunz18</a>],
followed by the Bulletproofs++ protocol by [<a href=https://link.springer.com/chapter/10.1007/978-3-031-58740-5_9 title="Bulletproofs++: next generation confidential transactions via reciprocal set membership arguments. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (pp. 249-279).">Eagen24</a>].</p><p>zk-STARKs were introduced by [<a href=https://link.springer.com/chapter/10.1007/978-3-030-26954-8_23 title="Ben-Sasson, E., Bentov, I., Horesh, Y., & Riabzev, M. (2019). Scalable zero knowledge with no trusted setup. In Advances in Cryptology–CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part III 39 (pp. 701-732).">Ben-Sasson19</a>].</p><p>Finally, if you want an intuitive but very comprehensive explanation of zk-SNARKs,
then you should read [<a href=https://arxiv.org/abs/1906.07221 title="Petkus, M. (2019). Why and How zk-SNARK works. arXiv preprint 1906.07221.">Petkus19</a>].</p><p>The following video from YouTube is from the
<a href=https://rdi.berkeley.edu/>Blockchain Web3 MOOC from Berkeley University</a>.
It provides a good introduction to Zero-Knowledge Proofs,
while being quite accessible to beginners.</p><style>.embed-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%}.embed-container iframe,.embed-container object,.embed-container embed{position:absolute;top:0;left:0;width:100%;height:100%}</style><div class=embed-container><iframe src=https://www.youtube.com/embed/gcKCW7CNu_M frameborder=0 allowfullscreen></iframe></div><br><p>This <a href=https://youtu.be/iRQw2RpQAVc>video from YouTube</a>
explains the math behind the Arithmetic Circuits
and how to encode them as polynomials.
I can&rsquo;t embed the video here, since the video owner has disabled embedding.</p><h2 id=license>License<a hidden class=anchor aria-hidden=true href=#license>#</a></h2><p>This post is licensed under <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p><p><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img loading=lazy src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt="CC BY-NC-SA 4.0"></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>A function $f$ is negligible if for every polynomial $p$,
there exists an $N$ such that for all $n > N$,
$$ f(n) &lt; \frac{1}{p(n)}. $$
If you want to learn more about negligible functions,
read Chapter 3, Section 3.1 of the book <a href=https://doi.org/10.1201/9781420010756>Introduction to Modern Cryptography</a> by Katz & Lindell.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>most of this section is based on <a href=https://arxiv.org/abs/1906.07221 title="Petkus, M. (2019). Why and How zk-SNARK works. arXiv preprint 1906.07221.">Petkus19</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>the &ldquo;at most&rdquo; is because we are talking about real-valued-only roots.
If we consider complex roots, then a polynomial of degree $d$ has exactly $d$ roots.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>the <a href=https://en.wikipedia.org/wiki/Birthday_problem>Birthday paradox</a>
states that any collision resistance scheme has a probability of $\frac{1}{2}$ of collision,
hence we take the square root of the number of possible values.
So, the security of the polynomial proof is $\sqrt{10^{77}} = 10^{38.5}$,
which is still a huge number.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>the number of edges entering a node&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://storopoli.io/tags/bitcoin/>Bitcoin</a></li><li><a href=https://storopoli.io/tags/cryptography/>Cryptography</a></li></ul><nav class=paginav><a class=prev href=https://storopoli.io/2023-11-28-zero_cost_abstractions/><span class=title>« Prev</span><br><span>Zero-cost Abstractions</span></a></nav></footer></article></main><footer class=footer><span><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>