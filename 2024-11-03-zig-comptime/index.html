<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zig comptime is such a powerful built-in feature | Jose Storopoli, PhD</title>
<meta name=keywords content="zig,compiler,rust"><meta name=description content="I have been following the development of Zig
for a while now.
I like the idea of a systems programming language
that is simple to learn and use,
yet powerful and expressive.
With Rust, I can get the powerful and expressive part,
but the learning curve is a bit steep,
and some parts of the language are complex
and hard to understand.
For example async/await (specially if you have to deal with Streams and Pins);
and the macro domain-specific language (DSL)."><meta name=author content="Jose Storopoli"><link rel=canonical href=https://storopoli.io/2024-11-03-zig-comptime/><link crossorigin=anonymous href=/assets/css/stylesheet.844bc2ac49bc9f1aa48de0c684bc0d8ec4ac8d4d88a84baa5bfb604a057e77fa.css integrity="sha256-hEvCrEm8nxqkjeDGhLwNjsSsjU2IqEuqW/tgSgV+d/o=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://storopoli.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://storopoli.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://storopoli.io/favicon-32x32.png><link rel=apple-touch-icon href=https://storopoli.io/apple-touch-icon.png><link rel=mask-icon href=https://storopoli.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://storopoli.io/2024-11-03-zig-comptime/><meta http-equiv=Content-Security-Policy content="default-src 'none'; img-src 'self'; script-src 'none'; font-src 'none'; style-src 'self'; connect-src 'none'; form-action 'none'; block-all-mixed-content; base-uri 'none'"><meta property="og:title" content="Zig comptime is such a powerful built-in feature"><meta property="og:description" content="I have been following the development of Zig
for a while now.
I like the idea of a systems programming language
that is simple to learn and use,
yet powerful and expressive.
With Rust, I can get the powerful and expressive part,
but the learning curve is a bit steep,
and some parts of the language are complex
and hard to understand.
For example async/await (specially if you have to deal with Streams and Pins);
and the macro domain-specific language (DSL)."><meta property="og:type" content="article"><meta property="og:url" content="https://storopoli.io/2024-11-03-zig-comptime/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-03T11:03:11-03:00"><meta property="article:modified_time" content="2024-11-03T13:37:37-03:00"><meta property="og:site_name" content="Jose Storopoli, PhD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zig comptime is such a powerful built-in feature"><meta name=twitter:description content="I have been following the development of Zig
for a while now.
I like the idea of a systems programming language
that is simple to learn and use,
yet powerful and expressive.
With Rust, I can get the powerful and expressive part,
but the learning curve is a bit steep,
and some parts of the language are complex
and hard to understand.
For example async/await (specially if you have to deal with Streams and Pins);
and the macro domain-specific language (DSL)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://storopoli.io/posts/"},{"@type":"ListItem","position":2,"name":"Zig comptime is such a powerful built-in feature","item":"https://storopoli.io/2024-11-03-zig-comptime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zig comptime is such a powerful built-in feature","name":"Zig comptime is such a powerful built-in feature","description":"I have been following the development of Zig for a while now. I like the idea of a systems programming language that is simple to learn and use, yet powerful and expressive.\nWith Rust, I can get the powerful and expressive part, but the learning curve is a bit steep, and some parts of the language are complex and hard to understand. For example async/await (specially if you have to deal with Streams and Pins); and the macro domain-specific language (DSL).\n","keywords":["zig","compiler","rust"],"articleBody":"I have been following the development of Zig for a while now. I like the idea of a systems programming language that is simple to learn and use, yet powerful and expressive.\nWith Rust, I can get the powerful and expressive part, but the learning curve is a bit steep, and some parts of the language are complex and hard to understand. For example async/await (specially if you have to deal with Streams and Pins); and the macro domain-specific language (DSL).\nNow back to Zig. The language can be learned in one lazy morning. That’s exactly what I did and then played around migrating some C code to Zig from an old course that I used to teach about algorithmic complexity. The code is now simpler and more readable than the original C code. I have hugely benefited from Zig’s built-in features such as:\nOptionals Error handling comptime (more on that, since it is the main topic of this post) safe integer/floating-point arithmetic deferring memory deallocation to the end of the scope structs with functions (methods) BYOA (Bring Your Own Allocator)1 Writing in Zig, comparing to C, is such a joy and you are always sure that you won’t spend hours debugging because Zig has:\nNo hidden control flow No hidden memory allocations No preprocessor, no macros I highly recommend you to give Zig a try. It is the ultimate C killer. In fact, you can compile and interop C and Zig code with Zig. So you can start migrating your C codebase to Zig incrementally. As an additional caveat, Zig can be faster than C2.\nZig’s comptime I’ve been wanting to write about Zig for a while now. But I had no topic in mind. Then, I was inspired by this talk by @matklad on modern systems programming comparing Rust and Zig interwoven with his professional journey from Rust to Zig, and the amazing work he’s doing at TigerBeetle:\nThe talk goes on to compare Rust and Zig in terms of systems programming. Then, at the middle of the talk, he starts to talk about Zig. One of the Zig’s features that he covers is Zig’s comptime feature which allows to run code and evaluate expressions at compile-time without the need for meta-programming/macros or code generation.\nLet me explain now what is comptime in Zig. You can do comptime in Zig in different places, such as:\nParameters of functions Variables Expressions Here are some examples thanks to Loris Cro and Zig’s documentation.\nParameters of functions The first Zig code example is about using comptime to decide the length of a statically-allocated array:\nfn multiply(a: i64, b: i64) i64 { return a * b; } pub fn main() void { const len = comptime multiply(4, 5); const my_static_array: [len]u8 = undefined; } Variables The second example is about using comptime to define a variable. This Zig code evaluates a Fibonacci number at compile-time:\nconst expect = @import(\"std\").testing.expect; fn fibonacci(index: u32) u32 { if (index \u003c 2) return index; return fibonacci(index - 1) + fibonacci(index - 2); } test \"fibonacci\" { // test fibonacci at run-time try expect(fibonacci(7) == 13); // test fibonacci at compile-time try comptime expect(fibonacci(7) == 13); } Expressions The final example is about using comptime to evaluate an expression. The following Zig code evaluates a for-loop at compile-time.\nconst max = 10; comptime var total = 0; comptime { for (1..max) |i| { total += i; } } Bonus example: Zig’s Generics Now you can see how impressive comptime is. In fact, Zig’s generics are implemented using comptime. Check the Zig code below that creates a generic List data structure:\nfn List(comptime T: type) type { return struct { items: []T, len: usize, }; } // The generic List data structure can be instantiated by passing in a type: var buffer: [10]i32 = undefined; var list = List(i32){ .items = \u0026buffer, .len = 0, }; The caveats of comptime comptime has some caveats. comptime expressions must be known at compile-time. That means:\nAt the callsite, the value must be known at compile-time, or it is a compile error. In the function definition, the value is known at compile-time. If you guarantee that the value is known at compile-time, you can use comptime to evaluate anything at compile-time.\nThe motivating example The motivating example for this blog post is an explanation that matklad gives in his talk about how they use comptime at TigerBeetle to make sure that a struct that represents a header has no padding in its fields.\nThen, he said that to have the same checks at compile-time in Rust, you would need to bring a lot of complexity with proc-macros. That made me curious about how hard it would be to do the same in Rust.\nSo here’s a toy problem that I came up with to compare Zig and Rust. Instead of checking for padding in fields of a struct, I decided to simplify and check for zero-padding in a string.\nZero padding check in Zig In Zig, strings are arrays of bytes, and you can iterate over them at compile-time:\nconst std = @import(\"std\"); fn checkZeroPadding(comptime s: []const u8) void { for (s) |c| { if (c == '0') { @compileError(\"String contains zero-padding\"); } } } pub fn main() void { comptime { const str1 = \"12345\"; const str2 = \"01234\"; checkZeroPadding(str1); // This will compile checkZeroPadding(str2); // This will cause a compile-time error } } The code above uses comptime to check if a string has zero-padding.\nZero padding check in Rust Compare this to how to do the same thing in Rust. We need to use a procedural macro to achieve the same result. Note that macros in Rust have their own domain-specific language (DSL) that is not Rust itself. Hence, you need to learn a new language to write a macro in Rust.\nFirst create a library crate named zero-padding-checker that exports a proc-macro and add a procedural macro to check for zero-padding in a string:\nuse proc_macro::TokenStream; use quote::quote; use syn::{parse_macro_input, LitStr}; #[proc_macro] pub fn check_zero_padding(input: TokenStream) -\u003e TokenStream { let input = parse_macro_input!(input as LitStr); let value = input.value(); if value.starts_with('0') { return quote! { compile_error!(\"String contains zero-padding\"); } .into(); } quote! { #input } .into() } Then you call the macro in your code:\nuse zero_padding_checker::check_zero_padding; fn main() { check_zero_padding!(\"12345\"); // This will compile check_zero_padding!(\"01234\"); // This will cause a compile-time error } The Rust code above is far more complex than the Zig code. First, it requires dependency on syn and quote crates (note that the proc-macro crate is provided by Rust’s compiler). Second, despite the fact that this is a simple example, procedural macros in Rust have their own domain-specific language (DSL) and the complexity can grow quickly as the problem becomes more complex3.\nConclusion Yeah, Zig is a great language and has a bright future ahead. comptime is a powerful feature that allows you to run almost any code at compile-time. It is built into the language and you don’t need to learn a new language to use it or bring external dependencies to make it work.\nIf you like to learn more about Zig, I recommend reading the learn section of Zig’s documentation. Also, to learn more about Zig’s comptime feature, check Zig’s documentation on comptime.\nLicense This post is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nZig doesn’t have a built-in allocator. And I don’t know it the acronym BYOA is a thing. I just made it up. But it makes sense, right? ↩︎\nIt is faster for the following reasons:\nThe reference implementation uses LLVM as a backend for state of the art optimizations. What other projects call “Link Time Optimization” Zig does automatically. For native targets, advanced CPU features are enabled (-march=native) Carefully chosen undefined behavior. Zig directly exposes a SIMD vector type, making it easy to write portable vectorized code. ↩︎ Take a look at some examples in The Little Book of Rust Macros ↩︎\n","wordCount":"1325","inLanguage":"en","datePublished":"2024-11-03T11:03:11-03:00","dateModified":"2024-11-03T13:37:37-03:00","author":{"@type":"Person","name":"Jose Storopoli"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://storopoli.io/2024-11-03-zig-comptime/"},"publisher":{"@type":"Organization","name":"Jose Storopoli, PhD","logo":{"@type":"ImageObject","url":"https://storopoli.io/favicon.svg"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://storopoli.io/ accesskey=h title="Jose Storopoli, PhD (Alt + H)">Jose Storopoli, PhD</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://storopoli.io/about/ title=About><span>About</span></a></li><li><a href=https://storopoli.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://storopoli.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://storopoli.io/>Home</a>&nbsp;»&nbsp;<a href=https://storopoli.io/posts/>Blog</a></div><h1 class="post-title entry-hint-parent">Zig comptime is such a powerful built-in feature</h1><div class=post-meta><span title='2024-11-03 11:03:11 -0300 -0300'>November 3, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Jose Storopoli&nbsp;|&nbsp;<a href=https://github.com/storopoli/storopoli.github.io/blob/main/content/posts/2024-11-03-zig-comptime/index.md rel="noopener noreferrer">Source code</a></div><div class=post-meta></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#zigs-comptime aria-label="Zig&rsquo;s comptime">Zig&rsquo;s comptime</a><ul><li><a href=#parameters-of-functions aria-label="Parameters of functions">Parameters of functions</a></li><li><a href=#variables aria-label=Variables>Variables</a></li><li><a href=#expressions aria-label=Expressions>Expressions</a></li><li><a href=#bonus-example-zigs-generics aria-label="Bonus example: Zig&rsquo;s Generics">Bonus example: Zig&rsquo;s Generics</a></li><li><a href=#the-caveats-of-comptime aria-label="The caveats of comptime">The caveats of comptime</a></li></ul></li><li><a href=#the-motivating-example aria-label="The motivating example">The motivating example</a><ul><li><a href=#zero-padding-check-in-zig aria-label="Zero padding check in Zig">Zero padding check in Zig</a></li><li><a href=#zero-padding-check-in-rust aria-label="Zero padding check in Rust">Zero padding check in Rust</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#license aria-label=License>License</a></li></ul></div></details></div><div class=post-content><p>I have been following the development of <a href=https://ziglang.org/>Zig</a>
for a while now.
I like the idea of a systems programming language
that is <strong>simple to learn and use,
<em>yet</em> powerful and expressive</strong>.</p><p>With Rust, I can get the powerful and expressive part,
<em>but</em> the <strong>learning curve is a bit steep</strong>,
and some parts of the language are <strong>complex
and hard to understand</strong>.
For example <code>async</code>/<code>await</code> (specially if you have to deal with <code>Stream</code>s and <code>Pin</code>s);
and the macro domain-specific language (DSL).</p><p>Now back to Zig.
The language can be learned in one lazy morning.
That&rsquo;s exactly what I did and then played around
<a href=https://github.com/storopoli/graphs-complexity/pull/21>migrating some C code to Zig from an old course</a>
that I used to teach about algorithmic complexity.
The code is now simpler and more readable than the original C code.
I have hugely benefited from Zig&rsquo;s built-in features such as:</p><ul><li><a href=https://ziglang.org/documentation/master/#Optionals><strong>Optionals</strong></a></li><li><a href=https://ziglang.org/documentation/master/#Errors><strong>Error handling</strong></a></li><li><a href=https://ziglang.org/documentation/master/#comptime><strong><code>comptime</code></strong> (more on that, since it is the main topic of this post)</a></li><li><a href=https://ziglang.org/documentation/master/#Operators><strong>safe integer/floating-point arithmetic</strong></a></li><li><a href=https://ziglang.org/documentation/master/#defer><strong>deferring memory deallocation</strong> to the end of the scope</a></li><li><a href=https://ziglang.org/documentation/master/#struct><strong><code>struct</code>s with functions</strong> (methods)</a></li><li><a href=https://ziglang.org/documentation/master/#Choosing-an-Allocator><strong>BYOA</strong> (Bring Your Own Allocator)</a><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul><p>Writing in Zig, comparing to C, is such a joy and you are always sure that
you won&rsquo;t spend hours debugging because Zig has:</p><ul><li><strong>No hidden control flow</strong></li><li><strong>No hidden memory allocations</strong></li><li><strong>No preprocessor, no macros</strong></li></ul><p>I highly recommend you to give Zig a try.
It is the <strong>ultimate C killer</strong>.
In fact, you can <strong>compile and interop C and Zig</strong> code with Zig.
So you can start migrating your C codebase to Zig incrementally.
As an additional caveat, <strong>Zig can be faster than C</strong><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h2 id=zigs-comptime>Zig&rsquo;s <code>comptime</code><a hidden class=anchor aria-hidden=true href=#zigs-comptime>#</a></h2><p>I&rsquo;ve been wanting to write about Zig for a while now.
But I had no topic in mind.
Then, I was inspired by this talk by <a href=https://matklad.github.io>@matklad</a>
on modern systems programming comparing
Rust and Zig interwoven with his
professional journey from Rust to Zig,
and the amazing work he&rsquo;s doing at
<a href=https://tigerbeetle.com>TigerBeetle</a>:</p><p><a href="https://youtu.be/4aLy6qjhHeo?t=1904"><img loading=lazy src=youtube_preview.jpg#center alt="Matklad - Modern Systems Programming: Rust and Zig"></a></p><p>The talk goes on to compare Rust and Zig in terms of systems programming.
Then, at the middle of the talk, he starts to talk about Zig.
One of the Zig&rsquo;s features that he covers is Zig&rsquo;s <code>comptime</code> feature
which allows to <strong>run code and evaluate expressions at compile-time</strong>
<em>without</em> the need for meta-programming/macros or code generation.</p><p>Let me explain now what is <code>comptime</code> in Zig.
You can do <code>comptime</code> in Zig in different places, such as:</p><ol><li><strong>Parameters of functions</strong></li><li><strong>Variables</strong></li><li><strong>Expressions</strong></li></ol><p>Here are some examples thanks to <a href=https://kristoff.it/blog/what-is-zig-comptime/>Loris Cro</a>
and <a href=https://ziglang.org/documentation/master/#comptime>Zig&rsquo;s documentation</a>.</p><h3 id=parameters-of-functions>Parameters of functions<a hidden class=anchor aria-hidden=true href=#parameters-of-functions>#</a></h3><p>The first Zig code example is about using <code>comptime</code>
to decide the length of a statically-allocated array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>multiply</span><span class=p>(</span><span class=n>a</span><span class=o>:</span><span class=w> </span><span class=kt>i64</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=o>:</span><span class=w> </span><span class=kt>i64</span><span class=p>)</span><span class=w> </span><span class=kt>i64</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>main</span><span class=p>()</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>multiply</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>const</span><span class=w> </span><span class=n>my_static_array</span><span class=o>:</span><span class=w> </span><span class=p>[</span><span class=n>len</span><span class=p>]</span><span class=kt>u8</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>undefined</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=variables>Variables<a hidden class=anchor aria-hidden=true href=#variables>#</a></h3><p>The second example is about using <code>comptime</code> to define a variable.
This Zig code evaluates a Fibonacci number at compile-time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>const</span><span class=w> </span><span class=n>expect</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@import</span><span class=p>(</span><span class=s>&#34;std&#34;</span><span class=p>).</span><span class=n>testing</span><span class=p>.</span><span class=n>expect</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>fibonacci</span><span class=p>(</span><span class=n>index</span><span class=o>:</span><span class=w> </span><span class=kt>u32</span><span class=p>)</span><span class=w> </span><span class=kt>u32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>fibonacci</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>fibonacci</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>test</span><span class=w> </span><span class=s>&#34;fibonacci&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// test fibonacci at run-time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=n>expect</span><span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>13</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// test fibonacci at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=kr>comptime</span><span class=w> </span><span class=n>expect</span><span class=p>(</span><span class=n>fibonacci</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>13</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=expressions>Expressions<a hidden class=anchor aria-hidden=true href=#expressions>#</a></h3><p>The final example is about using <code>comptime</code> to evaluate an expression.
The following Zig code evaluates a <code>for</code>-loop at compile-time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>const</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>comptime</span><span class=w> </span><span class=kr>var</span><span class=w> </span><span class=n>total</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>comptime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>..</span><span class=n>max</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>total</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=bonus-example-zigs-generics>Bonus example: Zig&rsquo;s Generics<a hidden class=anchor aria-hidden=true href=#bonus-example-zigs-generics>#</a></h3><p>Now you can see how impressive <code>comptime</code> is.
In fact, Zig&rsquo;s generics are implemented using <code>comptime</code>.
Check the Zig code below that creates a generic <code>List</code> data structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=k>fn</span><span class=w> </span><span class=n>List</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>T</span><span class=o>:</span><span class=w> </span><span class=kt>type</span><span class=p>)</span><span class=w> </span><span class=kt>type</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>items</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=n>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>len</span><span class=o>:</span><span class=w> </span><span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// The generic List data structure can be instantiated by passing in a type:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>var</span><span class=w> </span><span class=n>buffer</span><span class=o>:</span><span class=w> </span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=kt>i32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>undefined</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>var</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>List</span><span class=p>(</span><span class=kt>i32</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>items</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>buffer</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></div><h3 id=the-caveats-of-comptime>The caveats of <code>comptime</code><a hidden class=anchor aria-hidden=true href=#the-caveats-of-comptime>#</a></h3><p><code>comptime</code> has some caveats.
<code>comptime</code> expressions must be known at compile-time.
That means:</p><ol><li>At the callsite, the value must be known at compile-time, or it is a compile error.</li><li>In the function definition, the value is known at compile-time.</li></ol><p>If you guarantee that the value is known at compile-time,
you can use <code>comptime</code> to evaluate anything at compile-time.</p><h2 id=the-motivating-example>The motivating example<a hidden class=anchor aria-hidden=true href=#the-motivating-example>#</a></h2><p>The motivating example for this blog post is an explanation
that matklad gives in his talk about how they use <code>comptime</code> at TigerBeetle
to make sure that a <code>struct</code> that represents a header has no padding in its fields.</p><p><img loading=lazy src=header_padding.png alt="TigerBeetle&rsquo;s header struct"></p><p>Then, he said that to have the same checks at compile-time in Rust,
you would need to bring a lot of complexity with <code>proc-macro</code>s.
That made me curious about how hard it would be to do the same in Rust.</p><p>So here&rsquo;s a toy problem that I came up with to compare Zig and Rust.
Instead of checking for padding in fields of a <code>struct</code>,
I decided to simplify and check for zero-padding in a string.</p><h3 id=zero-padding-check-in-zig>Zero padding check in Zig<a hidden class=anchor aria-hidden=true href=#zero-padding-check-in-zig>#</a></h3><p>In Zig, strings are arrays of bytes,
and you can iterate over them at compile-time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zig data-lang=zig><span class=line><span class=cl><span class=kr>const</span><span class=w> </span><span class=n>std</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>@import</span><span class=p>(</span><span class=s>&#34;std&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>checkZeroPadding</span><span class=p>(</span><span class=kr>comptime</span><span class=w> </span><span class=n>s</span><span class=o>:</span><span class=w> </span><span class=p>[]</span><span class=kr>const</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#39;0&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>@compileError</span><span class=p>(</span><span class=s>&#34;String contains zero-padding&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kr>pub</span><span class=w> </span><span class=k>fn</span><span class=w> </span><span class=n>main</span><span class=p>()</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kr>comptime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>str1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;12345&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kr>const</span><span class=w> </span><span class=n>str2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;01234&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>checkZeroPadding</span><span class=p>(</span><span class=n>str1</span><span class=p>);</span><span class=w> </span><span class=c1>// This will compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>checkZeroPadding</span><span class=p>(</span><span class=n>str2</span><span class=p>);</span><span class=w> </span><span class=c1>// This will cause a compile-time error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The code above uses <code>comptime</code> to check if a string has zero-padding.</p><h3 id=zero-padding-check-in-rust>Zero padding check in Rust<a hidden class=anchor aria-hidden=true href=#zero-padding-check-in-rust>#</a></h3><p>Compare this to how to do the same thing in Rust.
We need to use a procedural macro to achieve the same result.
Note that <a href=https://doc.rust-lang.org/reference/macros.html>macros in Rust</a>
have their own domain-specific language (DSL) that is not Rust itself.
Hence, you need to learn a new language to write a macro in Rust.</p><p>First create a library crate named <code>zero-padding-checker</code>
that exports a <a href=https://doc.rust-lang.org/reference/procedural-macros.html><code>proc-macro</code></a>
and add a procedural macro to check for zero-padding in a string:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>proc_macro</span>::<span class=n>TokenStream</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>quote</span>::<span class=n>quote</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>syn</span>::<span class=p>{</span><span class=n>parse_macro_input</span><span class=p>,</span><span class=w> </span><span class=n>LitStr</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[proc_macro]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>check_zero_padding</span><span class=p>(</span><span class=n>input</span>: <span class=nc>TokenStream</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>TokenStream</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>parse_macro_input!</span><span class=p>(</span><span class=n>input</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>LitStr</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>.</span><span class=n>value</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=n>starts_with</span><span class=p>(</span><span class=sc>&#39;0&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=fm>quote!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>compile_error!</span><span class=p>(</span><span class=s>&#34;String contains zero-padding&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>into</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>quote!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>#<span class=n>input</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=n>into</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Then you call the macro in your code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>zero_padding_checker</span>::<span class=n>check_zero_padding</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>check_zero_padding!</span><span class=p>(</span><span class=s>&#34;12345&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// This will compile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>check_zero_padding!</span><span class=p>(</span><span class=s>&#34;01234&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// This will cause a compile-time error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The Rust code above is far more complex than the Zig code.
First, it requires dependency on <code>syn</code> and <code>quote</code> crates
(note that the <code>proc-macro</code> crate is provided by Rust&rsquo;s compiler).
Second, despite the fact that this is a simple example,
procedural macros in Rust have their own domain-specific language (DSL)
and the complexity can grow quickly as the problem becomes more complex<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Yeah, <strong>Zig is a great language and has a bright future ahead</strong>.
<strong><code>comptime</code></strong> is a powerful feature that allows you to <strong>run almost <em>any</em> code at compile-time</strong>.
It is built into the language and you don&rsquo;t need to learn a new language to use it
or bring external dependencies to make it work.</p><p>If you like to <strong>learn more about Zig</strong>, I recommend reading the
<a href=https://ziglang.org/learn/>learn section of Zig&rsquo;s documentation</a>.
Also, to learn more about <strong>Zig&rsquo;s <code>comptime</code></strong> feature,
check <a href=https://ziglang.org/documentation/master/#comptime>Zig&rsquo;s documentation on <code>comptime</code></a>.</p><h2 id=license>License<a hidden class=anchor aria-hidden=true href=#license>#</a></h2><p>This post is licensed under <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p><p><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img loading=lazy src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt="CC BY-NC-SA 4.0"></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Zig doesn&rsquo;t have a built-in allocator.
And I don&rsquo;t know it the acronym BYOA is a thing.
I just made it up. But it makes sense, right?&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>It is faster for the following reasons:</p><ol><li>The reference implementation uses LLVM as a backend for state of the art optimizations.</li><li>What other projects call &ldquo;Link Time Optimization&rdquo; Zig does automatically.
For native targets, advanced CPU features are enabled (<code>-march=native</code>)</li><li>Carefully chosen undefined behavior.</li><li>Zig directly exposes a SIMD vector type, making it easy to write portable vectorized code.</li></ol>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:3><p>Take a look at some examples in <a href=https://veykril.github.io/tlborm>The Little Book of Rust Macros</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://storopoli.io/tags/zig/>Zig</a></li><li><a href=https://storopoli.io/tags/compiler/>Compiler</a></li><li><a href=https://storopoli.io/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=https://storopoli.io/2024-06-08-zkp/><span class=title>« Prev</span><br><span>Zero-Knowledge Proofs</span></a></nav></footer></article></main><footer class=footer><span><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>