<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing Bayesian Models with Nix and GitHub Actions | Jose Storopoli, PhD</title>
<meta name=keywords content="bayesian,nix,CI/CD"><meta name=description content="I have an open access and open source1 graduate-level course on Bayesian statistics. It is available in GitHub through the repo storopoli/Bayesian-Statistics. I&rsquo;ve taught it many times and every time was such a joy. It is composed of:
a set of 300+ slides2 covering the theoretical part Stan3 models Turing.jl4 models Now and then I receive emails from someone saying that the materials helped them to understand Bayesian statistics. These kind messages really make my day, and that&rsquo;s why I strive to keep the content up-to-date and relevant."><meta name=author content="Jose Storopoli"><link rel=canonical href=https://storopoli.io/2023-12-04-bayesian_models_ci/><link crossorigin=anonymous href=/assets/css/stylesheet.5d45b8bd1a3cf526e72959d51f1bdc688d8e97fa0df2a697a93df6bdc746feb4.css integrity="sha256-XUW4vRo89SbnKVnVHxvcaI2Ol/oN8qaXqT32vcdG/rQ=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://storopoli.io/assets/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://storopoli.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://storopoli.io/favicon-32x32.png><link rel=apple-touch-icon href=https://storopoli.io/apple-touch-icon.png><link rel=mask-icon href=https://storopoli.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://storopoli.io/2023-12-04-bayesian_models_ci/><meta http-equiv=Content-Security-Policy content="default-src 'none'; img-src 'self'; script-src 'self'; font-src 'self'; style-src 'self'; connect-src 'self'; form-action 'none'; block-all-mixed-content; base-uri 'none'"><meta property="og:title" content="Testing Bayesian Models with Nix and GitHub Actions"><meta property="og:description" content="I have an open access and open source1 graduate-level course on Bayesian statistics. It is available in GitHub through the repo storopoli/Bayesian-Statistics. I&rsquo;ve taught it many times and every time was such a joy. It is composed of:
a set of 300+ slides2 covering the theoretical part Stan3 models Turing.jl4 models Now and then I receive emails from someone saying that the materials helped them to understand Bayesian statistics. These kind messages really make my day, and that&rsquo;s why I strive to keep the content up-to-date and relevant."><meta property="og:type" content="article"><meta property="og:url" content="https://storopoli.io/2023-12-04-bayesian_models_ci/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-04T17:43:03-03:00"><meta property="article:modified_time" content="2024-04-10T08:57:32-03:00"><meta property="og:site_name" content="Jose Storopoli, PhD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing Bayesian Models with Nix and GitHub Actions"><meta name=twitter:description content="I have an open access and open source1 graduate-level course on Bayesian statistics. It is available in GitHub through the repo storopoli/Bayesian-Statistics. I&rsquo;ve taught it many times and every time was such a joy. It is composed of:
a set of 300+ slides2 covering the theoretical part Stan3 models Turing.jl4 models Now and then I receive emails from someone saying that the materials helped them to understand Bayesian statistics. These kind messages really make my day, and that&rsquo;s why I strive to keep the content up-to-date and relevant."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://storopoli.io/posts/"},{"@type":"ListItem","position":2,"name":"Testing Bayesian Models with Nix and GitHub Actions","item":"https://storopoli.io/2023-12-04-bayesian_models_ci/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing Bayesian Models with Nix and GitHub Actions","name":"Testing Bayesian Models with Nix and GitHub Actions","description":"I have an open access and open source1 graduate-level course on Bayesian statistics. It is available in GitHub through the repo storopoli/Bayesian-Statistics. I\u0026rsquo;ve taught it many times and every time was such a joy. It is composed of:\na set of 300+ slides2 covering the theoretical part Stan3 models Turing.jl4 models Now and then I receive emails from someone saying that the materials helped them to understand Bayesian statistics. These kind messages really make my day, and that\u0026rsquo;s why I strive to keep the content up-to-date and relevant.","keywords":["bayesian","nix","CI/CD"],"articleBody":" I have an open access and open source1 graduate-level course on Bayesian statistics. It is available in GitHub through the repo storopoli/Bayesian-Statistics. I’ve taught it many times and every time was such a joy. It is composed of:\na set of 300+ slides2 covering the theoretical part Stan3 models Turing.jl4 models Now and then I receive emails from someone saying that the materials helped them to understand Bayesian statistics. These kind messages really make my day, and that’s why I strive to keep the content up-to-date and relevant.\nI decided to make the repository fully reproducible and testable in CI5 using Nix and GitHub actions.\nHere’s what I am testing on every new change to the main repository and every new pull request (PR):\nslides in LaTeX are built and released as PDF in CI typos in content and code are tested Turing.jl models are run and tested in CI using the latest version of Julia, Turing.jl and dependencies Stan models are run and test in CI using the latest version of Stan Nix All of these tests demand a highly reproducible and intricate development environment. That’s where Nix comes in. Nix can be viewed as a package manager, operating system, build tool, immutable system, and many things.\nNix is purely functional. Everything is described as an expression/function, taking some inputs and producing deterministic outputs. This guarantees reproducible results and makes caching everything easy. Nix expressions are lazy. Anything described in Nix code will only be executed if some other expression needs its results. This is very powerful but somewhat unnatural for developers not familiar with functional programming.\nI enjoy Nix so much that I use it as the operating system and package manager in all of my computers. Feel free to check my setup at storopoli/flakes.\nThe main essence of the repository setup is the flake.nix file. A Flake is a collection of recipes (Nix derivations) that the repository provides. From the NixOS Wiki article on Flakes:\nFlakes is a feature of managing Nix packages to simplify usability and improve reproducibility of Nix installations. Flakes manages dependencies between Nix expressions, which are the primary protocols for specifying packages. Flakes implements these protocols in a consistent schema with a common set of policies for managing packages.\nI use the Nix’s Flakes to not only setup the main repository package, defined in the Flake as just package.default which is the PDF build of the LaTeX slides, but also to setup the development environment, defined in the Flake as the devShell.default, to run the latest versions of Stan and Julia/Turing.jl.\nWe’ll go over the Flake file in detail. However, let me show the full Flake file:\n{ description = \"A basic flake with a shell\"; inputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\"; inputs.flake-utils.url = \"github:numtide/flake-utils\"; inputs.pre-commit-hooks.url = \"github:cachix/pre-commit-hooks.nix\"; outputs = { self, nixpkgs, flake-utils, pre-commit-hooks }: flake-utils.lib.eachDefaultSystem (system: let pkgs = nixpkgs.legacyPackages.${system}; tex = pkgs.texlive.combine { inherit (pkgs.texlive) scheme-small; inherit (pkgs.texlive) latexmk pgf pgfplots tikzsymbols biblatex beamer; inherit (pkgs.texlive) silence appendixnumberbeamer fira fontaxes mwe; inherit (pkgs.texlive) noto csquotes babel helvetic transparent; inherit (pkgs.texlive) xpatch hyphenat wasysym algorithm2e listings; inherit (pkgs.texlive) lstbayes ulem subfigure ifoddpage relsize; inherit (pkgs.texlive) adjustbox media9 ocgx2 biblatex-apa wasy; }; julia = pkgs.julia-bin.overrideDerivation (oldAttrs: { doInstallCheck = false; }); in { checks = { pre-commit-check = pre-commit-hooks.lib.${system}.run { src = ./.; hooks = { typos.enable = true; }; }; }; devShells.default = pkgs.mkShell { packages = with pkgs;[ bashInteractive # pdfpc # FIXME: broken on darwin typos cmdstan julia ]; shellHook = '' export JULIA_NUM_THREADS=\"auto\" export JULIA_PROJECT=\"turing\" export CMDSTAN_HOME=\"${pkgs.cmdstan}/opt/cmdstan\" ${self.checks.${system}.pre-commit-check.shellHook} ''; }; packages.default = pkgs.stdenvNoCC.mkDerivation rec { name = \"slides\"; src = self; buildInputs = with pkgs; [ coreutils tex gnuplot biber ]; phases = [ \"unpackPhase\" \"buildPhase\" \"installPhase\" ]; buildPhase = '' export PATH=\"${pkgs.lib.makeBinPath buildInputs}\"; cd slides export HOME=$(pwd) latexmk -pdflatex -shell-escape slides.tex ''; installPhase = '' mkdir -p $out cp slides.pdf $out/ ''; }; }); } A flake is composed primarily of inputs and outputs. As inputs I have:\ninputs.nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\"; inputs.flake-utils.url = \"github:numtide/flake-utils\"; inputs.pre-commit-hooks.url = \"github:cachix/pre-commit-hooks.nix\"; nixpkgs is responsible for providing all of the packages necessary for both package.default and devShell.default: cmdstan, julia-bin, typos, and a bunch of texlive LaTeX small packages. flake-utils are a bunch of Nix utility functions that creates tons of syntactic sugar to make the Flake easily accessible in all platforms, such as macOS and Linux. pre-commit-hooks is a nice Nix utility to create easy git hooks that do some checking at several steps of the git workflow. The only hook that I am using is the typos pre-commit hook that checks the whole commit changes for common typos and won’t let you commit successfully if you have typos: either correct or whitelist them in the _typos.toml file. The outputs are the bulk of the Flake file and it is a Nix function that takes all the above as inputs and outputs a couple of things:\noutputs = { self, nixpkgs, flake-utils, pre-commit-hooks }: flake-utils.lib.eachDefaultSystem (system: { checks = ... devShells = ... packages = ... }); checks things that are executed/built when you run nix flake check devShells things that are executed/built when you run nix develop packages things that are executed/built when you run nix build Let’s go over each one of the outputs that the repository Flake has.\npackages – LaTeX slides We all know that LaTeX is a pain to make it work. If it builds in my machine definitely won’t build in yours. This is solved effortlessly in Nix. Take a look at the tex variable definition in the let ... in block:\nlet # ... tex = pkgs.texlive.combine { inherit (pkgs.texlive) scheme-small; inherit (pkgs.texlive) latexmk pgf pgfplots tikzsymbols biblatex beamer; inherit (pkgs.texlive) silence appendixnumberbeamer fira fontaxes mwe; inherit (pkgs.texlive) noto csquotes babel helvetic transparent; inherit (pkgs.texlive) xpatch hyphenat wasysym algorithm2e listings; inherit (pkgs.texlive) lstbayes ulem subfigure ifoddpage relsize; inherit (pkgs.texlive) adjustbox media9 ocgx2 biblatex-apa wasy; }; # ... in tex is a custom instantiation of the texlive.combine derivation with some overrides to specify which CTAN packages you need to build the slides. We use tex in the packages.default Flake output:\npackages.default = pkgs.stdenvNoCC.mkDerivation rec { name = \"slides\"; src = self; buildInputs = with pkgs; [ coreutils tex gnuplot biber ]; phases = [ \"unpackPhase\" \"buildPhase\" \"installPhase\" ]; buildPhase = '' export PATH=\"${pkgs.lib.makeBinPath buildInputs}\"; cd slides export HOME=$(pwd) latexmk -pdflatex -shell-escape slides.tex ''; installPhase = '' mkdir -p $out cp slides.pdf $out/ ''; }; Here we are declaring a Nix derivation with the stdenvNoCC.mkDerivation, the NoCC part means that we don’t need C/C++ build tools. The src is the Flake repository itself and I also specify the dependencies in buildInputs: I still need some fancy stuff to build my slides. Finally, I specify the several phases of the derivation. The most important part is that I cd into the slides/ directory and run latexmk in it, and copy the resulting PDF to the $out Nix special directory which serves as the output directory for the derivation.\nThis is really nice because anyone with Nix installed can run:\nnix build github:storopoli/Bayesian-Statistics and bingo! You have my slides as PDF built from LaTeX files without having to clone or download the repository. Fully reproducible in any machine or architecture.\nThe next step is to configure GitHub actions to run Nix and build the slides' PDF file in CI. I have two workflows for that and they are almost identical except for the last step. The first one is the build-slides.yml, which, of course, builds the slides. These are the relevant parts:\nname: Build Slides runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Install Nix uses: DeterminateSystems/nix-installer-action@v8 - name: Build Slides run: nix build -L - name: Copy result out of nix store run: cp -v result/slides.pdf slides.pdf - name: Upload Artifacts uses: actions/upload-artifact@v3 with: name: output path: ./slides.pdf if-no-files-found: error Here we use a set of actions to:\ninstall Nix build the slides’ PDF file using nix build (the -L flag is to have more verbose logs) upload the built slides’ PDF file as an artifact of the CI run. This is useful for inspection and debugging. There is also the caveat that if the PDF file is not found the whole workflow should error. The last one is the release-slides.yml, which releases the slides when I publish a new tag. It is almost the same as build-slides.yml, thus I will only highlight the relevant bits:\non: push: tags: - \"*\" # ... - name: Release uses: ncipollo/release-action@v1 id: release with: artifacts: ./slides.pdf The only change is the final step that we now use a release-action that automatically publishes a release with the slides’ PDF file as one of the release artifacts. This is good since, once I achieve a milestone in the slides, I can easily tag a new version and have GitHub automatically publish a new release with the resulting PDF file attached in the release.\nThis is a very good workflow, both in GitHub but also locally. I don’t need to install tons of gigabytes of texlive stuff to build my slides locally. I just run nix build. Also, if someones contributes to the slides I don’t need to check the correctness of the LaTeX code, only the content and the output PDF artifact in the resulting CI from the PR. If it’s all good, just thank the blessed soul and merge it!\nTuring.jl Models The repository has a directory called turing/ which is a Julia project with .jl files and a Project.toml that lists the Julia dependencies and appropriate compat bounds. In order to test the Turing.jl models in the Julia files, I have the following things in the Nix Flake devShell:\nlet # ... julia = pkgs.julia-bin.overrideDerivation (oldAttrs: { doInstallCheck = false; }); # ... in # ... devShells.default = pkgs.mkShell { packages = with pkgs;[ # ... julia # ... ]; shellHook = '' # ... export JULIA_NUM_THREADS=\"auto\" export JULIA_PROJECT=\"turing\" # ... ''; }; Nix devShell lets you create a development environment by adding a transparent layer on top of your standard shell environment with additional packages, hooks, and environment variables. First, in the let ... in block, I am defining a variable called julia that is the julia-bin package with an attribute doInstallCheck being overridden to false. I don’t want the Nix derivation of the mkShell to run all Julia standard tests. Next, I define some environment variables in the shellHook, which, as the name implies, runs every time that I instantiate the default devShell with nix develop.\nWith the Nix Flake part covered, let’s check how we wrap everything in a GitHub action workflow file named models.yml. Again, I will only highlight the relevant parts for the Turing.jl model testing CI job:\njobs: test-turing: name: Test Turing Models runs-on: ubuntu-latest strategy: matrix: jl-file: [ \"01-predictive_checks.jl\", # ... \"13-model_comparison-roaches.jl\", ] steps: # ... - name: Test ${{ matrix.jl-file }} run: | nix develop -L . --command bash -c \"julia -e 'using Pkg; Pkg.instantiate()'\" nix develop -L . --command bash -c \"julia turing/${{ matrix.jl-file }}\" I list all the Turing.jl model Julia files in a matrix.jl-file list to define variations for each job. Next, we install the latest Julia version. Finally, we run everything in parallel using the YAML string interpolation ${{ matrix.jl-file }}. This expands the expression into N parallel jobs, where N is the jl-file list length.\nIf any of these parallel jobs error out, then the whole workflow will error. Hence, we are always certain that the models are up-to-date with the latest Julia version in nixpkgs, and the latest Turing.jl dependencies.\nStan Models The repository has a directory called stan/ that holds a bunch of Stan models in .stan files. These models can be used with any Stan interface, such as RStan/CmdStanR, PyStan/CmdStanPy, or Stan.jl. However I am using CmdStan which only needs a shell environment and Stan, no additional dependencies like Python, R, or Julia. Additionally, nixpkgs has a cmdstan package that is well-maintained and up-to-date with the latest Stan release.\nIn order to test the Stan models, I have the following setup in the Nix Flake devShell:\ndevShells.default = pkgs.mkShell { packages = with pkgs;[ # ... cmdstan # ... ]; shellHook = '' # ... export CMDSTAN_HOME=\"${pkgs.cmdstan}/opt/cmdstan\" # ... ''; }; Here I am also defining an environment variable in the shellHook, CMDSTAN_HOME because that is useful for local development.\nIn the same GitHub action workflow models.yml file is defined the Stan model testing CI job:\njobs: test-stan: name: Test Stan Models runs-on: ubuntu-latest strategy: matrix: stan: [ { model: \"01-predictive_checks-posterior\", data: \"coin_flip.data.json\", }, # ... { model: \"13-model_comparison-zero_inflated-poisson\", data: \"roaches.data.json\", }, ] steps: # ... - name: Test ${{ matrix.stan.model }} run: | echo \"Compiling: ${{ matrix.stan.model }}\" nix develop -L . --command bash -c \"stan stan/${{ matrix.stan.model }}\" nix develop -L . --command bash -c \"stan/${{ matrix.stan.model }} sample data file=stan/${{ matrix.stan.data }}\" Now I am using a YAML dictionary as the entry for every element in the stan YAML list with two keys: model and data. model lists the Stan model file without the .stan extension, and data lists the JSON data file that the model needs to run. We’ll use both to run parallel jobs to test all the Stan models listed in the stan list. For that we use the following commands:\nnix develop -L . --command bash -c \"stan stan/${{ matrix.stan.model }}\" nix develop -L . --command bash -c \"stan/${{ matrix.stan.model }} sample data file=stan/${{ matrix.stan.data }}\" This instantiates the devShell.default shell environment, and uses the stan binary provided by the cmdstan Nix package to compile the model into an executable binary. Next, we run this model executable binary in sample mode while also providing the corresponding data file with data file=.\nAs before, if any of these parallel jobs error out, then the whole workflow will error. Hence, we are always certain that the models are up-to-date with the latest Stan/CmdStan version in nixpkgs.\nConclusion I am quite happy with this setup. It makes easy to run test in CI with GitHub Actions, while also being effortless to instantiate a development environment with Nix. If I want to get a new computer up and running, I don’t need to install a bunch of packages and go over “getting started” instructions to have all the necessary dependencies.\nThis setup also helps onboard new contributors since it is:\neasy to setup the dependencies necessary to develop and test trivial to check if contributions won’t break anything Speaking of “contributors”, if you are interested in Bayesian modeling, feel free to go over the contents of the repository storopoli/Bayesian-Statistics. Contributions are most welcomed. Don’t hesitate on opening an issue or pull request.\nLicense This post is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nthe code is MIT-licensed and the content is CreativeCommons Non-Commercial 4.0 ↩︎\nI am also planning to go over the slides for every lecture in a YouTube playlist in the near future. This would make it the experience complete: slides, lectures, and code. ↩︎\na probabilistic programming language and suite of MCMC samplers written in C++. It is today’s gold standard in Bayesian stats. ↩︎\nis an ecosystem of Julia packages for Bayesian inference using probabilistic programming. ↩︎\nCI stands for continuous integration, sometimes also known as CI/CD, continuous integration and continuous delivery. CI/CD is a wide “umbrella” term for “everything that is tested in all parts of the development cicle”, and these tests commonly take place in a cloud machine. ↩︎\n","wordCount":"2568","inLanguage":"en","datePublished":"2023-12-04T17:43:03-03:00","dateModified":"2024-04-10T08:57:32-03:00","author":{"@type":"Person","name":"Jose Storopoli"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://storopoli.io/2023-12-04-bayesian_models_ci/"},"publisher":{"@type":"Organization","name":"Jose Storopoli, PhD","logo":{"@type":"ImageObject","url":"https://storopoli.io/assets/favicon.svg"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://storopoli.io/ accesskey=h title="Jose Storopoli, PhD (Alt + H)">Jose Storopoli, PhD</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://storopoli.io/about/ title=About><span>About</span></a></li><li><a href=https://storopoli.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://storopoli.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://storopoli.io/>Home</a>&nbsp;»&nbsp;<a href=https://storopoli.io/posts/>Blog</a></div><h1 class="post-title entry-hint-parent">Testing Bayesian Models with Nix and GitHub Actions</h1><div class=post-meta><span title='2023-12-04 17:43:03 -0300 -0300'>December 4, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Jose Storopoli&nbsp;|&nbsp;<a href=https://github.com/storopoli/storopoli.github.io/blob/main/content/posts/2023-12-04-bayesian_models_ci/index.md rel="noopener noreferrer">Source code</a></div><div class=post-meta><span title="2024-04-10 08:57:32 -0300 -0300"><i>Last updated on April 10, 2024</i></span></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#nix aria-label=Nix>Nix</a><ul><li><a href=#packages----latex-slides aria-label="packages &ndash; LaTeX slides">packages &ndash; LaTeX slides</a></li><li><a href=#turingjl-models aria-label="Turing.jl Models">Turing.jl Models</a></li><li><a href=#stan-models aria-label="Stan Models">Stan Models</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#license aria-label=License>License</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=bayesian-models-go-brrrrr.png#center alt=bayesian-models-go-brrrrr></p><p>I have an open access and open source<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> graduate-level course on Bayesian statistics.
It is available in GitHub through the repo <a href=https://github.com/storopoli/Bayesian-Statistics><code>storopoli/Bayesian-Statistics</code></a>.
I&rsquo;ve taught it many times and every time was such a joy.
It is composed of:</p><ul><li>a set of 300+ slides<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> covering the theoretical part</li><li><a href=https://mc-stan.org>Stan</a><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> models</li><li><a href=https://turinglang.org>Turing.jl</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> models</li></ul><p>Now and then I receive emails from someone saying that the materials helped
them to understand Bayesian statistics.
These kind messages really make my day, and that&rsquo;s why I strive to keep
the content up-to-date and relevant.</p><p>I decided to make the repository fully reproducible and testable in CI<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> using
<a href=https://nixos.org>Nix</a>
and <a href=https://docs.github.com/en/actions>GitHub actions</a>.</p><p>Here&rsquo;s what I am testing on every new change to the main repository
and every new pull request (PR):</p><ol><li><strong>slides in LaTeX</strong> are built and released as PDF in CI</li><li><strong>typos</strong> in content and code are tested</li><li><strong>Turing.jl models</strong> are run and tested in CI using the latest version of Julia,
Turing.jl and dependencies</li><li><strong>Stan models</strong> are run and test in CI using the latest version of Stan</li></ol><h2 id=nix>Nix<a hidden class=anchor aria-hidden=true href=#nix>#</a></h2><p>All of these tests demand a highly reproducible and intricate development
environment.
That&rsquo;s where <a href=https://nixos.org>Nix</a> comes in.
Nix can be viewed as a package manager, operating system, build tool,
immutable system, and many things.</p><p>Nix is purely functional.
Everything is described as an expression/function,
taking some inputs and producing deterministic outputs.
This guarantees reproducible results and makes caching everything easy.
Nix expressions are lazy. Anything described in Nix code will only be executed
if some other expression needs its results.
This is very powerful but somewhat unnatural for developers not familiar
with functional programming.</p><p>I enjoy Nix so much that I use it as the operating system and package manager in
all of my computers.
Feel free to check my setup at
<a href=https://github.com/storopoli/flakes><code>storopoli/flakes</code></a>.</p><p>The main essence of the repository setup is the
<a href=https://github.com/storopoli/Bayesian-Statistics/blob/main/flake.nix><code>flake.nix</code> file</a>.
A Flake is a collection of recipes (Nix derivations) that the repository
provides.
From the <a href=https://nixos.wiki/wiki/Flakes>NixOS Wiki article on Flakes</a>:</p><blockquote><p>Flakes is a feature of managing Nix packages to simplify usability and improve
reproducibility of Nix installations.
Flakes manages dependencies between Nix expressions,
which are the primary protocols for specifying packages.
Flakes implements these protocols in a consistent schema with a common set
of policies for managing packages.</p></blockquote><p>I use the Nix&rsquo;s Flakes to not only setup the main repository package,
defined in the Flake as just <code>package.default</code>
which is the PDF build of the LaTeX slides,
but also to setup the development environment,
defined in the Flake as the <code>devShell.default</code>,
to run the latest versions of
Stan and Julia/Turing.jl.</p><p>We&rsquo;ll go over the Flake file in detail.
However, let me show the full Flake file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>description</span> <span class=o>=</span> <span class=s2>&#34;A basic flake with a shell&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>inputs</span><span class=o>.</span><span class=n>nixpkgs</span><span class=o>.</span><span class=n>url</span> <span class=o>=</span> <span class=s2>&#34;github:NixOS/nixpkgs/nixpkgs-unstable&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>inputs</span><span class=o>.</span><span class=n>flake-utils</span><span class=o>.</span><span class=n>url</span> <span class=o>=</span> <span class=s2>&#34;github:numtide/flake-utils&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>inputs</span><span class=o>.</span><span class=n>pre-commit-hooks</span><span class=o>.</span><span class=n>url</span> <span class=o>=</span> <span class=s2>&#34;github:cachix/pre-commit-hooks.nix&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>outputs</span> <span class=o>=</span> <span class=p>{</span> <span class=n>self</span><span class=o>,</span> <span class=n>nixpkgs</span><span class=o>,</span> <span class=n>flake-utils</span><span class=o>,</span> <span class=n>pre-commit-hooks</span> <span class=p>}:</span>
</span></span><span class=line><span class=cl>    <span class=n>flake-utils</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=n>eachDefaultSystem</span> <span class=p>(</span><span class=n>system</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>let</span>
</span></span><span class=line><span class=cl>        <span class=n>pkgs</span> <span class=o>=</span> <span class=n>nixpkgs</span><span class=o>.</span><span class=n>legacyPackages</span><span class=o>.</span><span class=si>${</span><span class=n>system</span><span class=si>}</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tex</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=o>.</span><span class=n>combine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>scheme-small</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>latexmk</span> <span class=n>pgf</span> <span class=n>pgfplots</span> <span class=n>tikzsymbols</span> <span class=n>biblatex</span> <span class=n>beamer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>silence</span> <span class=n>appendixnumberbeamer</span> <span class=n>fira</span> <span class=n>fontaxes</span> <span class=n>mwe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>noto</span> <span class=n>csquotes</span> <span class=n>babel</span> <span class=n>helvetic</span> <span class=n>transparent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>xpatch</span> <span class=n>hyphenat</span> <span class=n>wasysym</span> <span class=n>algorithm2e</span> <span class=n>listings</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>lstbayes</span> <span class=n>ulem</span> <span class=n>subfigure</span> <span class=n>ifoddpage</span> <span class=n>relsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>adjustbox</span> <span class=n>media9</span> <span class=n>ocgx2</span> <span class=n>biblatex-apa</span> <span class=n>wasy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>julia</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>julia-bin</span><span class=o>.</span><span class=n>overrideDerivation</span> <span class=p>(</span><span class=n>oldAttrs</span><span class=p>:</span> <span class=p>{</span> <span class=n>doInstallCheck</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>checks</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>pre-commit-check</span> <span class=o>=</span> <span class=n>pre-commit-hooks</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=si>${</span><span class=n>system</span><span class=si>}</span><span class=o>.</span><span class=n>run</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>src</span> <span class=o>=</span> <span class=sr>./.</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hooks</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>              <span class=n>typos</span><span class=o>.</span><span class=n>enable</span> <span class=o>=</span> <span class=no>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>};</span>
</span></span><span class=line><span class=cl>          <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>devShells</span><span class=o>.</span><span class=n>default</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>mkShell</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>packages</span> <span class=o>=</span> <span class=k>with</span> <span class=n>pkgs</span><span class=p>;[</span>
</span></span><span class=line><span class=cl>            <span class=n>bashInteractive</span>
</span></span><span class=line><span class=cl>            <span class=c1># pdfpc # FIXME: broken on darwin</span>
</span></span><span class=line><span class=cl>            <span class=n>typos</span>
</span></span><span class=line><span class=cl>            <span class=n>cmdstan</span>
</span></span><span class=line><span class=cl>            <span class=n>julia</span>
</span></span><span class=line><span class=cl>          <span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=n>shellHook</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>            export JULIA_NUM_THREADS=&#34;auto&#34;
</span></span></span><span class=line><span class=cl><span class=s1>            export JULIA_PROJECT=&#34;turing&#34;
</span></span></span><span class=line><span class=cl><span class=s1>            export CMDSTAN_HOME=&#34;</span><span class=si>${</span><span class=n>pkgs</span><span class=o>.</span><span class=n>cmdstan</span><span class=si>}</span><span class=s1>/opt/cmdstan&#34;
</span></span></span><span class=line><span class=cl><span class=s1>            </span><span class=si>${</span><span class=n>self</span><span class=o>.</span><span class=n>checks</span><span class=o>.</span><span class=si>${</span><span class=n>system</span><span class=si>}</span><span class=o>.</span><span class=n>pre-commit-check</span><span class=o>.</span><span class=n>shellHook</span><span class=si>}</span><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>          &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>packages</span><span class=o>.</span><span class=n>default</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>stdenvNoCC</span><span class=o>.</span><span class=n>mkDerivation</span> <span class=k>rec</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;slides&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>src</span> <span class=o>=</span> <span class=n>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>buildInputs</span> <span class=o>=</span> <span class=k>with</span> <span class=n>pkgs</span><span class=p>;</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>coreutils</span>
</span></span><span class=line><span class=cl>            <span class=n>tex</span>
</span></span><span class=line><span class=cl>            <span class=n>gnuplot</span>
</span></span><span class=line><span class=cl>            <span class=n>biber</span>
</span></span><span class=line><span class=cl>          <span class=p>];</span>
</span></span><span class=line><span class=cl>          <span class=n>phases</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;unpackPhase&#34;</span> <span class=s2>&#34;buildPhase&#34;</span> <span class=s2>&#34;installPhase&#34;</span> <span class=p>];</span>
</span></span><span class=line><span class=cl>          <span class=n>buildPhase</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>            export PATH=&#34;</span><span class=si>${</span><span class=n>pkgs</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=n>makeBinPath</span> <span class=n>buildInputs</span><span class=si>}</span><span class=s1>&#34;;
</span></span></span><span class=line><span class=cl><span class=s1>            cd slides
</span></span></span><span class=line><span class=cl><span class=s1>            export HOME=$(pwd)
</span></span></span><span class=line><span class=cl><span class=s1>            latexmk -pdflatex -shell-escape slides.tex
</span></span></span><span class=line><span class=cl><span class=s1>          &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>installPhase</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>            mkdir -p $out
</span></span></span><span class=line><span class=cl><span class=s1>            cp slides.pdf $out/
</span></span></span><span class=line><span class=cl><span class=s1>          &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>A flake is composed primarily of <code>inputs</code> and <code>outputs</code>.
As <code>inputs</code> I have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=n>inputs</span><span class=o>.</span><span class=n>nixpkgs</span><span class=o>.</span><span class=n>url</span> <span class=err>=</span> <span class=s2>&#34;github:NixOS/nixpkgs/nixpkgs-unstable&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>inputs</span><span class=o>.</span><span class=n>flake-utils</span><span class=o>.</span><span class=n>url</span> <span class=err>=</span> <span class=s2>&#34;github:numtide/flake-utils&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>inputs</span><span class=o>.</span><span class=n>pre-commit-hooks</span><span class=o>.</span><span class=n>url</span> <span class=err>=</span> <span class=s2>&#34;github:cachix/pre-commit-hooks.nix&#34;</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><a href=https://github.com/NixOS/nixpkgs><strong><code>nixpkgs</code></strong></a>
is responsible for providing all of the packages necessary for both
<code>package.default</code> and <code>devShell.default</code>: <code>cmdstan</code>, <code>julia-bin</code>, <code>typos</code>,
and a bunch of <code>texlive</code> LaTeX small packages.</li><li><a href=https://github.com/numtide/flake-utils><strong><code>flake-utils</code></strong></a>
are a bunch of Nix utility functions that creates tons of
syntactic sugar to make the Flake easily accessible in all platforms,
such as macOS and Linux.</li><li><a href=https://github.com/cachix/pre-commit-hooks.nix><strong><code>pre-commit-hooks</code></strong></a>
is a nice Nix utility to create easy
<a href=https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks>git hooks</a>
that do some checking at several steps of the git workflow.
The only hook that I am using is the <a href=https://github.com/crate-ci/typos><code>typos</code></a>
pre-commit hook that checks the whole commit changes for common typos and won&rsquo;t
let you commit successfully if you have typos:
either correct or whitelist them in the <code>_typos.toml</code> file.</li></ul><p>The <code>outputs</code> are the bulk of the Flake file and it is a Nix function that
takes all the above as inputs and outputs a couple of things:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=n>outputs</span> <span class=err>=</span> <span class=p>{</span> <span class=n>self</span><span class=o>,</span> <span class=n>nixpkgs</span><span class=o>,</span> <span class=n>flake-utils</span><span class=o>,</span> <span class=n>pre-commit-hooks</span> <span class=p>}:</span>
</span></span><span class=line><span class=cl>    <span class=n>flake-utils</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=n>eachDefaultSystem</span> <span class=p>(</span><span class=n>system</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>checks</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>      <span class=n>devShells</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>      <span class=n>packages</span> <span class=o>=</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>   <span class=p>});</span>
</span></span></code></pre></div><ul><li><code>checks</code> things that are executed/built when you run <code>nix flake check</code></li><li><code>devShells</code> things that are executed/built when you run <code>nix develop</code></li><li><code>packages</code> things that are executed/built when you run <code>nix build</code></li></ul><p>Let&rsquo;s go over each one of the outputs that the repository Flake has.</p><h3 id=packages----latex-slides><code>packages</code> &ndash; LaTeX slides<a hidden class=anchor aria-hidden=true href=#packages----latex-slides>#</a></h3><p>We all know that LaTeX is a pain to make it work.
If it builds in my machine definitely won&rsquo;t build in yours.
This is solved effortlessly in Nix.
Take a look at the <code>tex</code> variable definition in the <code>let ... in</code> block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=k>let</span>
</span></span><span class=line><span class=cl>  <span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=n>tex</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=o>.</span><span class=n>combine</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>scheme-small</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>latexmk</span> <span class=n>pgf</span> <span class=n>pgfplots</span> <span class=n>tikzsymbols</span> <span class=n>biblatex</span> <span class=n>beamer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>silence</span> <span class=n>appendixnumberbeamer</span> <span class=n>fira</span> <span class=n>fontaxes</span> <span class=n>mwe</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>noto</span> <span class=n>csquotes</span> <span class=n>babel</span> <span class=n>helvetic</span> <span class=n>transparent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>xpatch</span> <span class=n>hyphenat</span> <span class=n>wasysym</span> <span class=n>algorithm2e</span> <span class=n>listings</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>lstbayes</span> <span class=n>ulem</span> <span class=n>subfigure</span> <span class=n>ifoddpage</span> <span class=n>relsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>inherit</span> <span class=p>(</span><span class=n>pkgs</span><span class=o>.</span><span class=n>texlive</span><span class=p>)</span> <span class=n>adjustbox</span> <span class=n>media9</span> <span class=n>ocgx2</span> <span class=n>biblatex-apa</span> <span class=n>wasy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=k>in</span>
</span></span></code></pre></div><p><code>tex</code> is a custom instantiation of the <code>texlive.combine</code> derivation with some
overrides to specify which CTAN packages you need to build the slides.
We use <code>tex</code> in the <code>packages.default</code> Flake <code>output</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=n>packages</span><span class=o>.</span><span class=n>default</span> <span class=err>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>stdenvNoCC</span><span class=o>.</span><span class=n>mkDerivation</span> <span class=k>rec</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;slides&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>src</span> <span class=o>=</span> <span class=n>self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>buildInputs</span> <span class=o>=</span> <span class=k>with</span> <span class=n>pkgs</span><span class=p>;</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>coreutils</span>
</span></span><span class=line><span class=cl>    <span class=n>tex</span>
</span></span><span class=line><span class=cl>    <span class=n>gnuplot</span>
</span></span><span class=line><span class=cl>    <span class=n>biber</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>phases</span> <span class=o>=</span> <span class=p>[</span> <span class=s2>&#34;unpackPhase&#34;</span> <span class=s2>&#34;buildPhase&#34;</span> <span class=s2>&#34;installPhase&#34;</span> <span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>buildPhase</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    export PATH=&#34;</span><span class=si>${</span><span class=n>pkgs</span><span class=o>.</span><span class=n>lib</span><span class=o>.</span><span class=n>makeBinPath</span> <span class=n>buildInputs</span><span class=si>}</span><span class=s1>&#34;;
</span></span></span><span class=line><span class=cl><span class=s1>    cd slides
</span></span></span><span class=line><span class=cl><span class=s1>    export HOME=$(pwd)
</span></span></span><span class=line><span class=cl><span class=s1>    latexmk -pdflatex -shell-escape slides.tex
</span></span></span><span class=line><span class=cl><span class=s1>  &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>installPhase</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    mkdir -p $out
</span></span></span><span class=line><span class=cl><span class=s1>    cp slides.pdf $out/
</span></span></span><span class=line><span class=cl><span class=s1>  &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Here we are declaring a Nix derivation with the <code>stdenvNoCC.mkDerivation</code>,
the <code>NoCC</code> part means that we don&rsquo;t need C/C++ build tools.
The <code>src</code> is the Flake repository itself and I also specify the dependencies
in <code>buildInputs</code>: I still need some fancy stuff to build my slides.
Finally, I specify the several <code>phases</code> of the derivation.
The most important part is that I <code>cd</code> into the <code>slides/</code> directory
and run <code>latexmk</code> in it, and copy the resulting PDF to the <code>$out</code> Nix
special directory which serves as the output directory for the derivation.</p><p>This is really nice because anyone with Nix installed can run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>nix build github:storopoli/Bayesian-Statistics
</span></span></code></pre></div><p>and bingo! You have my slides as PDF built from LaTeX files without having to
clone or download the repository.
Fully reproducible in any machine or architecture.</p><p>The next step is to configure GitHub actions to run Nix and build the slides'
PDF file in CI.
I have two workflows for that and they are almost identical except for the
last step.
The first one is the
<a href=https://github.com/storopoli/Bayesian-Statistics/blob/main/.github/workflows/build-slides.yml><code>build-slides.yml</code></a>,
which, of course, builds the slides.
These are the relevant parts:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build Slides</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout repository</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Nix</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>DeterminateSystems/nix-installer-action@v8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build Slides</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>nix build -L</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Copy result out of nix store</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cp -v result/slides.pdf slides.pdf</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Upload Artifacts</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/upload-artifact@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>output</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>./slides.pdf</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>if-no-files-found</span><span class=p>:</span><span class=w> </span><span class=l>error</span><span class=w>
</span></span></span></code></pre></div><p>Here we use a set of actions to:</p><ol><li>install Nix</li><li>build the slides&rsquo; PDF file using <code>nix build</code>
(the <code>-L</code> flag is to have more verbose logs)</li><li>upload the built slides&rsquo; PDF file as an artifact of the CI run.
This is useful for inspection and debugging.
There is also the caveat that if the PDF file is not found the whole workflow
should error.</li></ol><p>The last one is the
<a href=https://github.com/storopoli/Bayesian-Statistics/blob/main/.github/workflows/release-slides.yml><code>release-slides.yml</code></a>,
which releases the slides when I publish a new tag.
It is almost the same as <code>build-slides.yml</code>, thus I will only highlight the
relevant bits:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>tags</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;*&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Release</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>ncipollo/release-action@v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>release</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>artifacts</span><span class=p>:</span><span class=w> </span><span class=l>./slides.pdf</span><span class=w>
</span></span></span></code></pre></div><p>The only change is the final step that we now use a <code>release-action</code>
that automatically publishes a release with the slides&rsquo; PDF file as one of the
release artifacts.
This is good since, once I achieve a milestone in the slides,
I can easily tag a new version and have GitHub automatically publish a new
release with the resulting PDF file attached in the release.</p><p>This is a very good workflow, both in GitHub but also locally.
I don&rsquo;t need to install tons of gigabytes of texlive stuff to build my slides
locally.
I just run <code>nix build</code>.
Also, if someones contributes to the slides I don&rsquo;t need to check the correctness
of the LaTeX code, only the content and the output PDF artifact in the
resulting CI from the PR.
If it&rsquo;s all good, just thank the blessed soul and merge it!</p><h3 id=turingjl-models>Turing.jl Models<a hidden class=anchor aria-hidden=true href=#turingjl-models>#</a></h3><p>The repository has a directory called <code>turing/</code> which is a Julia project with
<code>.jl</code> files and a <code>Project.toml</code> that lists the Julia dependencies and
appropriate <code>compat</code> bounds.
In order to test the Turing.jl models in the Julia files,
I have the following things in the Nix Flake <code>devShell</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=k>let</span>
</span></span><span class=line><span class=cl>  <span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=n>julia</span> <span class=o>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>julia-bin</span><span class=o>.</span><span class=n>overrideDerivation</span> <span class=p>(</span><span class=n>oldAttrs</span><span class=p>:</span> <span class=p>{</span> <span class=n>doInstallCheck</span> <span class=o>=</span> <span class=no>false</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=k>in</span>
</span></span><span class=line><span class=cl><span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=n>devShells</span><span class=o>.</span><span class=n>default</span> <span class=err>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>mkShell</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>packages</span> <span class=o>=</span> <span class=k>with</span> <span class=n>pkgs</span><span class=p>;[</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl>    <span class=n>julia</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>shellHook</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    # ...
</span></span></span><span class=line><span class=cl><span class=s1>    export JULIA_NUM_THREADS=&#34;auto&#34;
</span></span></span><span class=line><span class=cl><span class=s1>    export JULIA_PROJECT=&#34;turing&#34;
</span></span></span><span class=line><span class=cl><span class=s1>    # ...
</span></span></span><span class=line><span class=cl><span class=s1>  &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Nix <code>devShell</code> lets you create a development environment by adding a
transparent layer on top of your standard shell environment with additional
packages, hooks, and environment variables.
First, in the <code>let ... in</code> block, I am defining a variable called <code>julia</code>
that is the <code>julia-bin</code> package with an attribute <code>doInstallCheck</code>
being overridden to <code>false</code>.
I don&rsquo;t want the Nix derivation of the <code>mkShell</code> to run all Julia standard tests.
Next, I define some environment variables in the <code>shellHook</code>,
which, as the name implies, runs every time that I instantiate the default
<code>devShell</code> with <code>nix develop</code>.</p><p>With the Nix Flake part covered, let&rsquo;s check how we wrap everything in a
GitHub action workflow file named
<a href=https://github.com/storopoli/Bayesian-Statistics/blob/main/.github/workflows/models.yml><code>models.yml</code></a>.
Again, I will only highlight the relevant parts for the Turing.jl model testing
CI job:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test-turing</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test Turing Models</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>strategy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>matrix</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>jl-file</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s2>&#34;01-predictive_checks.jl&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c># ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=s2>&#34;13-model_comparison-roaches.jl&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test ${{ matrix.jl-file }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          nix develop -L . --command bash -c &#34;julia -e &#39;using Pkg; Pkg.instantiate()&#39;&#34;
</span></span></span><span class=line><span class=cl><span class=sd>          nix develop -L . --command bash -c &#34;julia turing/${{ matrix.jl-file }}&#34;</span><span class=w>          
</span></span></span></code></pre></div><p>I list all the Turing.jl model Julia files in a <code>matrix.jl-file</code> list
to
<a href=https://docs.github.com/actions/using-jobs/using-a-matrix-for-your-jobs>define variations for each job</a>.
Next, we install the latest Julia version.
Finally, we run everything in parallel using the YAML string interpolation
<code>${{ matrix.jl-file }}</code>.
This expands the expression into <code>N</code> parallel jobs,
where <code>N</code> is the <code>jl-file</code> list length.</p><p>If any of these parallel jobs error out, then the whole workflow will error.
Hence, we are always certain that the models are up-to-date with the latest Julia
version in <code>nixpkgs</code>, and the latest Turing.jl dependencies.</p><h3 id=stan-models>Stan Models<a hidden class=anchor aria-hidden=true href=#stan-models>#</a></h3><p>The repository has a directory called <code>stan/</code> that holds a bunch of Stan models
in <code>.stan</code> files.
These models can be used with any Stan interface,
such as
<a href=https://mc-stan.org/rstan><code>RStan</code></a>/<a href=https://mc-stan.org/cmdstanr><code>CmdStanR</code></a>,
<a href=https://pystan.readthedocs.org/en/latest/><code>PyStan</code></a>/<a href=https://mc-stan.org/cmdstanpy><code>CmdStanPy</code></a>,
or <a href=https://github.com/goedman/Stan.jl><code>Stan.jl</code></a>.
However I am using <a href=https://mc-stan.org/docs/cmdstan-guide/index.html><code>CmdStan</code></a>
which only needs a shell environment and Stan, no additional dependencies
like Python, R, or Julia.
Additionally, <code>nixpkgs</code> has a
<a href="https://search.nixos.org/packages?query=cmdstan"><code>cmdstan</code></a>
package that is well-maintained and up-to-date with the latest Stan release.</p><p>In order to test the Stan models,
I have the following setup in the Nix Flake <code>devShell</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=n>devShells</span><span class=o>.</span><span class=n>default</span> <span class=err>=</span> <span class=n>pkgs</span><span class=o>.</span><span class=n>mkShell</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>packages</span> <span class=o>=</span> <span class=k>with</span> <span class=n>pkgs</span><span class=p>;[</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl>    <span class=n>cmdstan</span>
</span></span><span class=line><span class=cl>    <span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>shellHook</span> <span class=o>=</span> <span class=s1>&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    # ...
</span></span></span><span class=line><span class=cl><span class=s1>    export CMDSTAN_HOME=&#34;</span><span class=si>${</span><span class=n>pkgs</span><span class=o>.</span><span class=n>cmdstan</span><span class=si>}</span><span class=s1>/opt/cmdstan&#34;
</span></span></span><span class=line><span class=cl><span class=s1>    # ...
</span></span></span><span class=line><span class=cl><span class=s1>  &#39;&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Here I am also defining an environment variable in the <code>shellHook</code>,
<code>CMDSTAN_HOME</code> because that is useful for local development.</p><p>In the same GitHub action workflow
<a href=https://github.com/storopoli/Bayesian-Statistics/blob/main/.github/workflows/models.yml><code>models.yml</code></a>
file is defined the Stan model testing CI job:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test-stan</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test Stan Models</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>strategy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>matrix</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>stan</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>{<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>model</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;01-predictive_checks-posterior&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>data</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;coin_flip.data.json&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>}<span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c># ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>{<span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>model</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;13-model_comparison-zero_inflated-poisson&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>data</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;roaches.data.json&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>}<span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test ${{ matrix.stan.model }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          echo &#34;Compiling: ${{ matrix.stan.model }}&#34;
</span></span></span><span class=line><span class=cl><span class=sd>          nix develop -L . --command bash -c &#34;stan stan/${{ matrix.stan.model }}&#34;
</span></span></span><span class=line><span class=cl><span class=sd>          nix develop -L . --command bash -c &#34;stan/${{ matrix.stan.model }} sample data file=stan/${{ matrix.stan.data }}&#34;</span><span class=w>          
</span></span></span></code></pre></div><p>Now I am using a YAML dictionary as the entry for every element in the <code>stan</code>
YAML list with two keys: <code>model</code> and <code>data</code>.
<code>model</code> lists the Stan model file without the <code>.stan</code> extension,
and <code>data</code> lists the JSON data file that the model needs to run.
We&rsquo;ll use both to run parallel jobs to test all the Stan models listed in the
<code>stan</code> list.
For that we use the following commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nix data-lang=nix><span class=line><span class=cl><span class=n>nix</span> <span class=n>develop</span> <span class=err>-</span><span class=n>L</span> <span class=o>.</span> <span class=err>--</span><span class=n>command</span> <span class=n>bash</span> <span class=err>-</span><span class=n>c</span> <span class=s2>&#34;stan stan/</span><span class=si>${</span><span class=p>{</span> <span class=n>matrix</span><span class=o>.</span><span class=n>stan</span><span class=o>.</span><span class=n>model</span> <span class=p>}</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=n>nix</span> <span class=n>develop</span> <span class=err>-</span><span class=n>L</span> <span class=o>.</span> <span class=err>--</span><span class=n>command</span> <span class=n>bash</span> <span class=err>-</span><span class=n>c</span> <span class=s2>&#34;stan/</span><span class=si>${</span><span class=p>{</span> <span class=n>matrix</span><span class=o>.</span><span class=n>stan</span><span class=o>.</span><span class=n>model</span> <span class=p>}</span><span class=si>}</span><span class=s2> sample data file=stan/</span><span class=si>${</span><span class=p>{</span> <span class=n>matrix</span><span class=o>.</span><span class=n>stan</span><span class=o>.</span><span class=n>data</span> <span class=p>}</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>This instantiates the <code>devShell.default</code> shell environment,
and uses the <code>stan</code> binary provided by the <code>cmdstan</code> Nix package to compile the
model into an executable binary.
Next, we run this model executable binary in <code>sample</code> mode while also providing
the corresponding data file with <code>data file=</code>.</p><p>As before, if any of these parallel jobs error out, then the whole workflow will
error.
Hence, we are always certain that the models are up-to-date with the latest
Stan/CmdStan version in <code>nixpkgs</code>.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I am quite happy with this setup.
It makes easy to run test in CI with GitHub Actions,
while also being effortless to instantiate a development environment with Nix.
If I want to get a new computer up and running, I don&rsquo;t need to install a bunch
of packages and go over &ldquo;getting started&rdquo; instructions to have all the necessary
dependencies.</p><p>This setup also helps onboard new contributors since it is:</p><ol><li>easy to setup the dependencies necessary to develop and test</li><li>trivial to check if contributions won&rsquo;t break anything</li></ol><p>Speaking of &ldquo;contributors&rdquo;, if you are interested in Bayesian modeling,
feel free to go over the contents of the repository
<a href=https://github.com/storopoli/Bayesian-Statistics><code>storopoli/Bayesian-Statistics</code></a>.
<strong>Contributions are most welcomed</strong>.
Don&rsquo;t hesitate on opening an issue or pull request.</p><h2 id=license>License<a hidden class=anchor aria-hidden=true href=#license>#</a></h2><p>This post is licensed under <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p><p><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img loading=lazy src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt="CC BY-NC-SA 4.0"></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>the code is MIT-licensed and the content is CreativeCommons
Non-Commercial 4.0&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I am also planning to go over the slides for every lecture
in a YouTube playlist in the near future.
This would make it the experience complete: slides, lectures, and code.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>a probabilistic programming language and suite of MCMC samplers written in C++.
It is today&rsquo;s gold standard in Bayesian stats.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>is an ecosystem of Julia packages for Bayesian inference using probabilistic
programming.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>CI stands for <strong>c</strong>ontinuous <strong>i</strong>ntegration,
sometimes also known as CI/CD, <strong>c</strong>ontinuous <strong>i</strong>ntegration and <strong>c</strong>ontinuous
<strong>d</strong>elivery.
<a href=https://en.wikipedia.org/wiki/CI/CD>CI/CD</a> is a wide &ldquo;umbrella&rdquo; term
for &ldquo;everything that is tested in all parts of the development cicle&rdquo;,
and these tests commonly take place in a cloud machine.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://storopoli.io/tags/bayesian/>Bayesian</a></li><li><a href=https://storopoli.io/tags/nix/>Nix</a></li><li><a href=https://storopoli.io/tags/ci/cd/>CI/CD</a></li></ul><nav class=paginav><a class=prev href=https://storopoli.io/2024-03-23-dead-man-switch/><span class=title>« Prev</span><br><span>Sherlock Holmes Final Letter: A Simple Dead Man's Switch in Rust</span>
</a><a class=next href=https://storopoli.io/2023-11-10-2023-11-13-soydev/><span class=title>Next »</span><br><span>What is soydev? And why do I hate it</span></a></nav></footer></article></main><footer class=footer><span><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>