<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="Jose Storopoli, PhD - personal website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@storopoli">
    <meta name="twitter:author" content="@storopoli">
    <meta name="twitter:description" content="Jose Storopoli, PhD - personal website">
    <meta name="twitter:title" content="Merkle Trees and the Taproot Protocol | @stropoli">
    <meta name="twitter:image" content="https://storopoli.io/pp.jpg">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Merkle Trees and the Taproot Protocol | @storopoli">
    <meta property="og:image" content="https://storopoli.io/pp.jpg">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Merkle Trees and the Taproot Protocol
      - @storopoli
    </title>
    <link rel="stylesheet" type="text/css" href="/main.css">
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/fira_code.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link type="text/css" rel="stylesheet" href="/term-highlight.css">
    
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"
    crossorigin="anonymous"
  >
  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4"
    crossorigin="anonymous"
  ></script>
  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body);"
  ></script>
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false },
        ],
      });
    });
  </script>

  </head>
  <body>
    <div id="content">
      <style>
        h1,
        h2,
        h3 {
          text-align: center;
        }

        .profile-pic {
          border-radius: 50%;
          border: 5px solid lightblue;
          margin-top: 1rem;
        }
      </style>
      <div style="display:flex; flex-direction:column; align-items:center;">
        <h1 id="header" class="noupper" style="margin-bottom:0;">
          Jose Storopoli, PhD
        </h1>
        <div class="menu" style="display:flex; justify-content:center; ">
          <a href="/">Home</a>
          •
          <a href="/blog/">Blog</a>
          •
          <a href="https://github.com/storopoli" target="_blank">
            GitHub
          </a>
          •
          <a href="/publickey.txt" target="_blank">
            PGP
          </a>
          •
          <a href="/index.xml" rel="alternate" type="application/rss+xml">
            RSS
          </a>
        </div>
      </div>
      
  <h1>Merkle Trees and the Taproot Protocol</h1>
  <p class="post-byline">
    <span>November 15, 2024</span>
    •
    <span>9</span>
    min read • by
    <b>Jose Storopoli, PhD</b>
    <span></span>
  </p>
  <div id="post-description"></div>
  <div>
    <div class="toc block info">
      <h1>&nbsp;Table of Contents</h1>
      <div><ul>
<li>
<ul><li>
<a href="#taproot"><a href="#taproot">Taproot</a></li><li><a href="#merkle-trees"><a href="#merkle-trees">Merkle Trees</a><ul><li>
<a href="#merkle-trees-as-commitment-schemes"><a href="#merkle-trees-as-commitment-schemes">Merkle Trees as Commitment Schemes</a></li></ul></li><li><a href="#taproot-and-merkle-trees"><a href="#taproot-and-merkle-trees">Taproot and Merkle Trees</a></li><li><a href="#why-is-this-useful"><a href="#why-is-this-useful">Why is this useful?</a></li><li><a href="#further-reading"><a href="#further-reading">Further Reading</a></li></ul></ul></div>
    </div>
  </div>
  <div>
    <div class="block warning">
      <h1>&nbsp;Math Equations</h1>
      This post has
      <a href="https://katex.org/">KaTeX</a>
      enabled,
      so if you want to view the rendered math formulas,
      you'll have to unfortunately enable JavaScript.
    </div>
  </div>
  <div id="content">
    <div id="post-body"><div class="block info"><p> Dedicated to John Peter, since I was tired of having to explain this to him every time we met.</p></div><p>This post gives an intuition to the <strong>Taproot protocol</strong> in Bitcoin, specifically how <strong>Merkle trees</strong> are used to hide the complexity of several possible spending conditions.</p><div id=taproot><h2><a class="" href="#taproot">Taproot</a></h2><p>Taproot was activated as a soft fork in the Bitcoin network on <strong>November 2021</strong>.</p><p>The <strong>design goals of Taproot</strong> are:</p><ul><li><strong>Increase privacy</strong>: hide the spending conditions and also hide the fact that you are using a multisig.</li><li><strong>Reduce the amount of data on-chain</strong>: you only need to commit to the root of a Merkle tree, and not the leaves.</li><li><strong>Use Schnorr</strong>: Schnorr signatures are more efficient and allow for signature aggregation.</li></ul><p>My focus is on the middle point: how to use Merkle trees to hide the complexity of the spending conditions. I’m not gonna cover Schnorr signatures here, but you can check <a href="https://conduition.io/cryptography/schnorr/" target="_blank">conduition’s excellent post on Schnorr signatures</a>.</p><p>So let’s start with Merkle trees.</p></div><div id=merkle-trees><h2><a class="" href="#merkle-trees">Merkle Trees</a></h2><p>A <a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank"><strong>Merkle tree</strong></a> is a binary tree where the leaves are the data and the internal nodes are the hash of their children. The root of the tree is called the <strong>Merkle root</strong>.</p><p>Here’s an example:</p><pre><code>              root
             /    \
            /      \
           /        \
          /          \
         /            \
        /              \
    H(0 | 1)        H(2 | 3)
      /   \           /    \
     /     \         /      \
    0       1       2        3
</code></pre><p>In the picture above, the leaves are the numbers 0, 1, 2, and 3. Consider these as data that you want to commit to. We construct the tree by hashing (applying the hash function $H$) the leaves and then concatenating the hashes, and hashing the result until we reach the root.</p></div><div id=merkle-trees-as-commitment-schemes><h3><a class="" href="#merkle-trees-as-commitment-schemes">Merkle Trees as Commitment Schemes</a></h3><p>In cryptography, we have something called a <a href="https://en.wikipedia.org/wiki/Commitment_scheme" target="_blank"><strong>commitment scheme</strong></a>.</p><p>A commitment scheme allows you to commit to a value without revealing it. This property is called <strong>hiding</strong>. Commitment schemes are designed so that a party cannot change the value or statement after they have committed to it. This property is called <strong>binding</strong>.</p><p>The classical example is a <strong>hash function</strong>. Say you have a value $x$ and you want to commit to it. You can hash $x$ and send the hash to the other party. In the future, you can reveal $x$ and the other party can hash it and check if it matches the hash you sent.</p><p>This is a commitment scheme because you cannot know the value of $x$ by looking at the hash. Hence, it is hiding. And you cannot change the value of $x$ without changing the hash, hence it is binding.</p><p>However, this is a commitment scheme for a single value. What if you have multiple values you want to commit to? This is where Merkle trees come in.</p><p><strong>Merkle trees are commitment schemes</strong>. You commit to the root of the tree, and you can prove that a leaf is in the tree by revealing the path from the leaf to the root.</p><p>It is hiding because you cannot know the value of a leaf by looking at the root. And it is binding because you cannot change the value of a leaf without changing the root.</p><p>Note that the inclusion proof is logarithmic in the number of leaves, hence the complexity of the inclusion proof is $O(\log n)$, where $n$ is the number of leaves, or the depth of the desired leaf in the tree. This makes Merkle trees a very efficient commitment scheme.</p></div><div id=taproot-and-merkle-trees><h2><a class="" href="#taproot-and-merkle-trees">Taproot and Merkle Trees</a></h2><p>Now that we understand Merkle trees, let’s see how they are used in Taproot. The anatomy of a <strong>Pay-to-Taproot (P2TR) address</strong> is as follows:</p><ol><li><strong>Internal key</strong>: the public key of the owner.</li><li><strong>Merkle root</strong>: the root of the Merkle tree of spending conditions.</li></ol><p>These are also called the <strong>key path</strong> and the <strong>script path</strong>, respectively. You can find more about the Taproot soft fork in the <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki" target="_blank">BIP 341</a> that describes Taproot spending rules.</p><div class="block info"><p> Note that there are ways to tweak the internal key that I will not cover here for simplicity. They are mainly used to disable the key path in a verifiable way and force the spending to only use script path conditions. Again, check <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki" target="_blank">BIP 341</a> for more details.</p></div><p>Here’s an example of a Taproot address:</p><pre><code>               +------+
               | P2TR |
               +------+
                  |
         +--------+--------+
         |                 |
     +-----------+   +-------------+
     | Internal  |   | Root of the |
     |   Key     |   |  Merkle Tree|
     +-----------+   +-------------+
                         |
               +---------+---------+
               |                   |
           +-------+           +-------+
           |   S1  |           |  Node |
           +-------+           +-------+
                                   |
                           +-------+-------+
                           |               |
                       +-------+       +-------+
                       |   S2  |       |   S3  |
                       +-------+       +-------+
</code></pre><p>Here we can see that we have the internal key and the root of the Merkle tree. The internal key is the key path, and the Merkle tree is the script path. If you want to spend from this address, you can either use the internal key or any of the spending conditions $S_n$ that are leaves in the Merkle tree.</p><p>Let’s focus in the spending conditions $S_n$. We have 3 conditions in the example above. These are vanilla Pay-to-(Witness)-Script-Hash P2SH scripts, so you can have multisig, timelocks, etc. in these conditions. P2SH scripts are not revealed on-chain, you just commit to the hash of the script. They are only revealed when you spend from the address, where you need to reveal the script and Bitcoin consensus will not only check if the script is correct, but also that it matches the hash committed.</p><div class="block info"><p> Yes, P2SH is a commitment scheme. It is hiding because you cannot know the script by looking at the hash. And it is binding because you cannot change the script without changing the hash.</p></div><p>In a Merkle tree, it takes $O(\log n)$ space to prove inclusion, where $n$ is the depth of the leaf that we want to prove, we order the leaves in the tree in such a way that the most likely conditions are closer to the root.</p><p>In this case we have $S_1$ as the most likely condition, and $S_2$ and $S_3$ as less likely conditions.</p><p>Suppose you want to spend from the address using $S_2$. How would you prove that $S_2$ is in the tree? Well, you need to reveal the path from $S_2$ to the root. This entails revealing the hash of the sibling of $S_2$, that is the hash of $S_3$, Ok now we got the “Node” in the picture above, but we still need to reveal the hash of the sibling of “Node”, that is $S_1$. This is enough to prove that $S_2$ is in the tree. See that we had to reveal the hashes of $S_1$ and $S_3$, since $S_2$ has depth $n = 3$ in the tree it took $\lceil O(\log 3) \rceil = 2$ steps to prove inclusion.</p><p>Now, suppose you want to spend from the address using $S_1$. Same thing, you need to reveal the path from $S_1$ to the root. This is easily done with just revealing the hash of “Node”. So a single operation is enough to prove inclusion. This is due to the fact that $S_1$ has depth $n = 2$ in the tree, hence it took $\lceil O(\log 2) \rceil = 1$ step to prove inclusion.</p><p>This is the beauty of Merkle trees.</p><p>Contrast this with other script addresses formats such as P2SH. In P2SH, you are only tied to a single script. You could have a bunch of nested IFs in the script, to emulate the same behavior as the Merkle tree, but good luck paying the fees for that monstrous script when you want to spend from the address.</p></div><div id=why-is-this-useful><h2><a class="" href="#why-is-this-useful">Why is this useful?</a></h2><p>I work at <a href="https://alpenlabs.io/" target="_blank">Alpen Labs</a>, where we are developing <a href="https://stratabtc.org" target="_blank">Strata</a>, a <a href="https://bitvm.org/" target="_blank">BitVM</a>-based bridge for Bitcoin. To put it simply, BitVM is a computing paradigm to express Turing-complete Bitcoin contracts.</p><p>BitVM was only possible due to the Taproot soft fork. Before we dive into details, just one minor detail about Merkle trees in Taproot: they can have a maximum depth of 128. This means that you can have up to $2^{128}$ spending conditions. And each of this spending conditions is a script that follows the Bitcoin consensus rules. Mostly important of these is that the transaction size must be less than 4MB. So, you can have a Taproot address that encodes a Turing-complete contract with up to $2^{128}$ clauses. And each of these clauses can be a complex script up to 4MB in size. Hence, we can hide the complexity of a Turing-complete contract in a single Taproot address. This allows us to encode $2^{128} \cdot 4\text{MB}$ of data which is more than the <strong>estimated data content of the surface web</strong>, according to <a href="https://www.wolframalpha.com/input?i=2%5E128+*+4mb" target="_blank">wolframalpha</a>.</p><p>More specifically, we can encode a gigabyte-sized <a href="https://eprint.iacr.org/2016/260" target="_blank">Groth16</a> verifier in Bitcoin script as a Taproot address by splitting the execution of the verifier into 4MB chunks and encoding each chunk as a spending condition as a leaf in a Taproot Merkle tree. And we can pass state between these chunks by using one-time signatures, such as <a href="https://en.wikipedia.org/wiki/Lamport_signature" target="_blank">Lamport Signatures</a>. This involves encoding all the ellyptic curve operations and pairings required by the Groth16 verifier along with a way to express Lamport signature verification in Bitcoin script. But this is a topic for a future post.</p><div class="block info"><p> If you want to know more about how to encode a Groth16 verifier using Bitcoin script, check the <a href="https://www.alpenlabs.io/blog" target="_blank">alpenlabs blog</a>.</p></div></div><div id=further-reading><h2><a class="" href="#further-reading">Further Reading</a></h2><p>The idea behind this post is to give an intuition to the Taproot protocol and how Merkle trees are used to hide the complexity of the spending conditions. There is a bunch of technical details that I left out for simplicity. Please go over the <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki" target="_blank">BIP 341</a> to check all the technicalities of Taproot, such as the different ways to tweak the internal key, tagged hashes, and Taproot annexes.</p><p>Merkle trees were introduced by Ralph Merkle in 1979. If you want to know more about Merkle trees, check <a href="https://toc.cryptobook.us/" target="_blank">Section 8.9 of Dan Boneh’s textbook “A Graduate Course in Applied Cryptography”</a>. They are used in many applications in computer science, for example file systems use Merkle trees to verify the integrity of files. Another example is the Nix package manager, which uses Merkle trees to ensure reproducibility of builds.</p><p>There are many variations of Merkle trees, for example Etereum uses a Patricia Merkle tree, a combination of a Merkle tree and a <a href="https://en.wikipedia.org/wiki/Patricia_trie" target="_blank">Patricia trie</a>, which is a <a href="https://en.wikipedia.org/wiki/Trie" target="_blank">“Merkle” trie</a> where the keys are hashed.</p></div></div>
  </div>
  <hr>
  <div id="prev-next">
    <span>
      <a href="/blog/2024-11-10-road-less-travelled/">←
        <span>The Road Less Travelled</span></a>
    </span>
    <span></span>
    <span></span>
    <small>&nbsp; or &nbsp;</small>
    <small>
      <a href="/">Back to the Homepage</a>
    </small>
  </div>

    </div>
    <footer id="footer">
      <small class="noupper" style="color:#606060;font-weight:normal;">
        <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
          CC-BY-SA 4.0
        </a>
         &nbsp;
        —
        &nbsp;
        <a href="https://github.com/storopoli" target="_blank">
          Jose Storopoli, PhD
        </a>
         &nbsp;
        —
        &nbsp;
        <i>made with &nbsp;
          <a href="https://zine-ssg.io" target="_blank">
            <img src="/zig-logo-light.svg" height="13">
          </a></i>
      </small>
      
    </footer>
  </body>
</html>