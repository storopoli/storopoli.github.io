<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cryptography Basics | Jose Storopoli, PhD</title>
<meta name=keywords content="cryptography,bitcoin"><meta name=description content="
     
            Euclid&rsquo;s one-way function
        



Warning: This post has KaTeX enabled,
so if you want to view the rendered math formulas,
you&rsquo;ll have to unfortunately enable JavaScript."><meta name=author content="Jose Storopoli"><link rel=canonical href=https://storopoli.io/2024-02-05-crypto-basics/><link crossorigin=anonymous href=/assets/css/stylesheet.5d45b8bd1a3cf526e72959d51f1bdc688d8e97fa0df2a697a93df6bdc746feb4.css integrity="sha256-XUW4vRo89SbnKVnVHxvcaI2Ol/oN8qaXqT32vcdG/rQ=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://storopoli.io/assets/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://storopoli.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://storopoli.io/favicon-32x32.png><link rel=apple-touch-icon href=https://storopoli.io/apple-touch-icon.png><link rel=mask-icon href=https://storopoli.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://storopoli.io/2024-02-05-crypto-basics/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:title" content="Cryptography Basics"><meta property="og:description" content="
     
            Euclid&rsquo;s one-way function
        



Warning: This post has KaTeX enabled,
so if you want to view the rendered math formulas,
you&rsquo;ll have to unfortunately enable JavaScript."><meta property="og:type" content="article"><meta property="og:url" content="https://storopoli.io/2024-02-05-crypto-basics/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-05T18:53:28-03:00"><meta property="article:modified_time" content="2024-04-15T09:24:31-03:00"><meta property="og:site_name" content="Jose Storopoli, PhD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cryptography Basics"><meta name=twitter:description content="
     
            Euclid&rsquo;s one-way function
        



Warning: This post has KaTeX enabled,
so if you want to view the rendered math formulas,
you&rsquo;ll have to unfortunately enable JavaScript."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://storopoli.io/posts/"},{"@type":"ListItem","position":2,"name":"Cryptography Basics","item":"https://storopoli.io/2024-02-05-crypto-basics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cryptography Basics","name":"Cryptography Basics","description":" Euclid\u0026rsquo;s one-way function\nWarning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you\u0026rsquo;ll have to unfortunately enable JavaScript.\n","keywords":["cryptography","bitcoin"],"articleBody":" Euclid’s one-way function\nWarning: This post has KaTeX enabled, so if you want to view the rendered math formulas, you’ll have to unfortunately enable JavaScript.\nThis is the companion post to the cryptography workshop that I gave at a local BitDevs. Let’s explore the basics of cryptography. We’ll go through the following topics:\nOne-way functions Hash functions Public-key cryptography DSA Schnorr Why we don’t reuse nonces? Why we can combine Schnorr Signatures and not DSA? One-way functions A one-way function is a function that is easy to compute on every input, but hard to invert given the image1 of a random input. For example, imagine an omelet. It’s easy to make an omelet from eggs, but it’s hard to make eggs from an omelet. In a sense we can say that the function $\\text{omelet}$ is a one-way function\n$$\\text{omelet}^{-1}(x) = \\ldots$$\nThat is, we don’t know how to invert the function $\\text{omelet}$ to get the original eggs back. Or, even better, the benefit we get from reverting the omelet to eggs is not worth the effort, either in time or money.\nNot all functions are one-way functions. The exponential function, $f(x) = e^x$, is not a one-way function. It is easy to undo the exponential function by taking the natural logarithm,\n$$f^{-1}(x) = \\ln(x)$$\nTo showcase one-way functions, let’s take a look at the following example. Let’s play around with some numbers. Not any kind of numbers, but very special numbers called primes. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\nIf I give you a big number $n$ and ask you to find its prime factors, and point a gun at your head, you’ll pretty much screwed. There’s no known efficient algorithm2 to factorize a big number into its prime factors. You’ll be forced to test all numbers from 2 to $\\sqrt{n}$ to see if they divide $n$.\nHere’s a number:\n$$90809$$\nWhat are its prime factors? It’s $1279 \\cdot 71$. Easy to check, right? Hard to find. That’s because prime factorization, if you choose a fucking big number, is a one-way function.\nHash Functions Let’s spice things up. There is a special class of one-way functions called hash functions.\nA hash function is any function that can be used to map data of arbitrary size to fixed-size values.\nBut we are most interested in cryptographic hash functions, which are hash functions that have statistical properties desirable for cryptographic application:\nOne-way function: easy to compute $y = f(x)$, hard as fuck to do the opposite, $x = f^{-1}(y)$. Deterministic: given a function that maps elements from set $X$ to set $Y$, $f: X \\to Y$, for every $x \\in X$ there’s at least one $y \\in Y$3. This means that if I give you a certain input, it will always map to the same output. It is deterministic. Collision resistance: the possible values of $f: X \\to Y$ follows a uniform distribution, that is, given the size of the set $Y$, it is hard to find two $x_1, x_2 \\in X$ that have the same $y \\in Y$ value4. This property is really important because if an attacker wants to brute-force the hash function, there’s no option than searching uniformly across the whole possible space of possible values that the hash function outputs5. These properties make enable cryptographic hash functions to be used in a wide range of applications, including but not limited to:\nDigital signatures: Hash functions are used to create a digest of the message to be signed. The digital signature is then generated using the hash, rather than the message itself, to ensure integrity and non-repudiation.\nPassword hashing: Storing passwords as hash values instead of plain text. Even if the hash values are exposed, the original passwords remain secure due to the pre-image resistance property.\nBlockchain and cryptocurrency: Hash functions are used to maintain the integrity of the blockchain. Each block contains the hash of the previous block, creating a secure link. Cryptographic hashes also underpin various aspects of cryptocurrency transactions.\nData integrity verification: Hash functions are used to ensure that files, messages, or data blocks have not been altered. By comparing hash values computed before and after transmission or storage, any changes in the data can be detected.\nWe’ll cover just the digital signatures part in this post.\nSHA-2 and its variants The Secure Hash Algorithm 2 (SHA-2) is a set of cryptographic hash functions designed by the National Security Agency (NSA). It was first published in 2001.\nIt is composed of six hash functions with digests that are 224, 256, 384, 512, 512/224, and 512/256 bits long:\nSHA-224 SHA-256 SHA-384 SHA-512 SHA-512/224 SHA-512/256 Amongst these, let’s focus on SHA-256, which is the most widely used while also being notoriously adopted by bitcoin.\nSHA-256 does not have any known vulnerabilities and is considered secure. It comprises of 32-bit words and operates on 64-byte blocks. The algorithm does 64 rounds of the following operations:\nAND: bitwise boolean AND XOR: bitwise boolean XOR OR: bitwise boolean OR ROT: right rotation bit shift ADD: addition modulo $2^{32}$ You can check SHA-256 Pseudocode on Wikipedia. It really scrambles the input message in a way that is very hard to reverse.\nThese operations are non-linear and very difficult to keep track of. In other words, you can’t reverse-engineer the hash to find the original message. There’s no “autodiff” for hash functions.\nSince it is a cryptographic hash function, if we change just one bit of the input, the output will be completely different. Check this example:\n$ echo \"The quick brown fox jumps over the lazy dog\" | shasum -a 256 c03905fcdab297513a620ec81ed46ca44ddb62d41cbbd83eb4a5a3592be26a69 - $ echo \"The quick brown fox jumps over the lazy dog.\" | shasum -a 256 b47cc0f104b62d4c7c30bcd68fd8e67613e287dc4ad8c310ef10cbadea9c4380 - Here we are only adding a period at the end of the sentence, and the hash is completely different. This is due to the property of collision resistance that we mentioned earlier.\nFields Before we dive into public-key cryptography, we need a brief interlude on fields.\nFields are sets with two binary operations, called addition $+$ and multiplication $\\times$. We write\n$$F = (F, +, \\times)$$\nto denote a field, where $F$ is the set, $+$ is the addition operation, and $\\times$ is the multiplication operation.\nAddition and multiplication behave similar to the addition and multiplication of real numbers. For example, addition is commutative and associative\n$$a + b = b + a,$$\nand multiplication is distributive\n$$a \\times (b + c) = a \\times b + a \\times c.$$\nAlso, there are two special elements in the field, called the additive identity $-a$ and the multiplicative identity $a^{-1}$, such that\n$$a + (-a) = I,$$\nand\n$$a \\times a^{-1} = I,$$\nwhere $I$ is the identity element.\nNote that this allows us to define subtraction\n$$a - b = a + (-b),$$\nand division\n$$a \\div b = a \\times b^{-1}.$$\nFinite Fields Now we are ready for finite fields. A finite field, also called a Galois field (in honor of Évariste Galois), is a field with a finite number of elements. As with any field, a finite field is a set on which the operations of multiplication, addition, subtraction and division are defined and satisfy the rules above for fields.\nFinite fields is a very rich topic in mathematics, and there are many ways to construct them. The easiest way to construct a finite field is to take the integers modulo a prime number $p$. For example $\\mathbb{Z}_5$ is a finite field with 5 elements:\n$$\\mathbb{Z}_5 = \\lbrace 0, 1, 2, 3, 4 \\rbrace.$$\nIn general, $\\mathbb{Z}_n$ is a finite field with $n$ elements:\n$$\\mathbb{Z}_n = \\lbrace 0, 1, 2, \\ldots, n - 1 \\rbrace.$$\nThe number of elements in a finite field is called the order of the field. The order of a finite field is always a prime number $p$. The $\\mathbb{Z}_5$ example above is a finite field of order 5. However, $\\mathbb{Z}_4$ is not a finite field, because 4 is not a prime number, but rather a composite number.\n$$4 = 2 \\times 2.$$\nAnd we can write $\\mathbb{Z}_4$ as\n$$\\mathbb{Z}_4 = 2 \\times \\mathbb{Z}_2.$$\nThis means that every element in $a \\in \\mathbb{Z}_4$ can be written as\n$$a = 2 \\times b,$$\nwhere $b$ is an element in $\\mathbb{Z}_2$.\nHence, not every element of $\\mathbb{Z}_4$ is unique, and they are equivalent to the elements in $\\mathbb{Z}_2$.\nIn general if $n$ is a composite number, then $\\mathbb{Z}_n$ is not a finite field. However, if $n = r \\times s$ where $r$ and $s$ are prime numbers, and $r \u003c s$, then $\\mathbb{Z}_n$ is a finite field of order $r$.\nOperations in Finite Fields Addition in finite fields is defined as the remainder of the sum of two elements modulo the order of the field.\nFor example, in $\\mathbb{Z}_3$,\n$$1 + 2 = 3 \\mod 3 = 0.$$\nWe can also define subtraction in finite fields as the remainder of the difference of two elements modulo the order of the field.\nFor example, in $\\mathbb{Z}_3$,\n$$1 - 2 = -1 \\mod 3 = 2.$$\nMultiplication in finite fields can be written as multiple additions. For example, in $\\mathbb{Z}_3$,\n$$2 \\times 2 = 2 + 2 = 4 \\mod 3 = 1.$$\nExponentiation in finite fields can be written as multiple multiplications. For example, in $\\mathbb{Z}_3$,\n$$2^2 = 2 \\times 2 = 4 \\mod 3 = 1.$$\nAs you can see addition, subtraction, and multiplication becomes linear operations. This is very trivial for any finite field.\nHowever, for division we are pretty much screwed. It is really hard to find the multiplicative inverse of an element in a finite field. For example, suppose that we have numbers $a,b$ in a very large finite field $\\mathbb{Z}_p$, such that\n$$c = a \\times b \\mod p.$$\nThen we can write division as\n$$a = c \\div b = c \\times b^{-1} \\mod p.$$\nNow we need to find $b^{-1}$, which is the multiplicative inverse of $b$. This is called the discrete logarithm problem. Because we need to find $b^{-1}$ such that\n$$b^{-1} = \\log_b c \\mod p.$$\nSince this number is a discrete number and not a real number, that’s why it’s called the discrete logarithm problem.\nGood luck my friend, no efficient method is known for computing them in general. You can try brute force, but that’s not efficient.\nWhy the Discrete Logarithm Problem is Hard as Fuck To get a feeling why the discrete logarithm problem is difficult, let’s add one more concept to our bag of knowledge. Every finite field has generators, also known as primitive roots, which is also a member of the group, such that applying multiplication to this one single element makes possible to generate the whole finite field.\nLet’s illustrate this with an example. Below we have a table of all the results of the following operation\n$$b^x \\mod 7$$\nfor every possible value of $x$. As you’ve guessed right this is the $\\mathbb{Z}_7$ finite field.\n$b$ $b^1 \\mod 7$ $b^2 \\mod 7$ $b^3 \\mod 7$ $b^4 \\mod 7$ $b^5 \\mod 7$ $b^6 \\mod 7$ $1$ $1$ $1$ $1$ $1$ $1$ $1$ $2$ $2$ $4$ $1$ $2$ $4$ $1$ $3$ $3$ $2$ $6$ $4$ $5$ $1$ $4$ $4$ $2$ $1$ $4$ $2$ $1$ $5$ $5$ $4$ $6$ $2$ $3$ $1$ $6$ $6$ $1$ $6$ $1$ $1$ $1$ You see that something interesting is happening here. For specific values of $b$, such as $b = 3$, and $b = 5$, we are able to generate the whole finite field. Hence, say that $3$ and $5$ are generators or primitive roots of $\\mathbb{Z}_7$.\nNow suppose I ask you to find $x$ in the following equation\n$$3^x \\mod p = 11$$\nwhere $p$ is a very large prime number. Then you don’t have any other option than brute forcing it. You’ll need to try each exponent $x \\in \\mathbb{Z}_p$ until you find the one that satisfies the equation.\nNotice that this operation is very asymmetric. It is very easy to compute $3^x \\mod p$ for any $x$, but it is very hard to find $x$ given $3^x \\mod p$.\nNow we are ready to dive into public-key cryptography.\nNumerical Example of the Discrete Logarithm Problem Let’s illustrate the discrete logarithm problem with a numerical example.\nChoose a prime number $p$. Let’s pick $p = 17$. Choose a generator $g$ of the group. For $p = 17$, we can choose $g = 3$ because $3$ is a primitive root of $\\mathbb{Z}_{17}$. Choose an element $x$. Let’s pick $x = 15$. The discrete logarithm problem is to find $x$ given $g^x \\mod p$. So let’s plug in the numbers; find $x$ in\n$$3^x = 15 \\mod 17 $$\nTry to find it. Good luck6.\nPublic-key cryptography Public-key cryptography, or asymmetric cryptography, is a cryptographic system that uses pairs of keys: private and public. The public key you can share with anyone, but the private key you must keep secret. The keys are related mathematically, but it is computationally infeasible to derive the private key from the public key. In other words, the public key is a one-way function of the private key.\nBefore we dive into the details of the public-key cryptography, and signing and verifying messages, let me introduce some notation:\n$p$: big fucking huge prime number (4096 bits or more) $\\mathbb{Z}_p$: the finite field of order $p$ $g$: a generator of $\\mathbb{Z}_p$ $S_k$: secret key, a random integer in the finite field $\\mathbb{Z}_p$ $P_k$: public key derived by $P_k = g^{S_k}$ If you know $S_k$ and $g$ (which is almost always part of the spec), then it’s easy to derive the $P_k$. However, if you only know $g$ and $P_k$, good luck finding $S_k$. It’s the discrete log problem again. And as long $p$ is HUGE you are pretty confident that no one will find your secret key from your public key.\nNow what we can do with these keys and big prime numbers? We’ll we can sign a message with our secret key and everyone can verify the authenticity of the message using our public key. The message in our case it is commonly a hash function of the “original message”. Due to the collision resistance property, we can definitely assert that:\nthe message has not been altered the message was signed by the owner of the private key Fun fact, I once gave a recommendation letter to a very bright student, that was only a plain text file signed with my private key. I could rest assured that the letter was not altered, and the student and other people could verify that I was the author of the letter.\nNext, we’ll dive into the details of the Digital Signature Algorithm (DSA) and the Schnorr signature algorithm.\nDSA DSA stands for Digital Signature Algorithm. It was first proposed by the National Institute of Standards and Technology (NIST) in 1991. Note that OpenSSH announced that DSA is scheduled for removal in 2025.\nHere’s how you can sign a message using DSA:\nChoose two prime numbers $p, q$ such that $p - 1 \\mod q = 0$ (e.g., 1279 and 71). Choose your private key $S_k$ as a random integer $\\in [1, q-1]$. Choose a generator $g$. Compute your public key $P_k$: $g^{S_k} \\mod p$. Choose your nonce $k$: as a random integer $\\in [1, q-1]$. Compute your “public nonce” $K$: $(g^k \\mod p) \\mod q$ (also known as $r$). Get your message ($m$) through a cryptographic hash function $H$: $H(m)$. Compute your signature $s$: $(k^{-1} (H(m) + S_k K)) \\mod q$. Send to your buddy $(p, q, g)$, $P_k$, and $(K, s)$. And here’s how you can verify the signature:\nCompute $w = s^{-1} \\mod q$. Compute $u_1 = H{m} \\cdot w \\mod q$. Compute $u_2 = K \\cdot w \\mod q$. Compute $K^* = {g^{u_1} P^{u_2}_k \\mod p} \\mod q$. Assert $K = K^*$. How this works? Let’s go through a proof of correctness. I added some comments to every operation in parentheses to make it easier to follow.\n$s = k^{-1} \\cdot {H + S_k K} \\mod q$ ($\\mod p$ and $H(m)$ implicit). $k = s^{-1} \\cdot {H + S_k K} \\mod q$ (move $s$ to $k$). $k = H \\cdot s^{-1} + S_k K \\cdot s^{-1} \\mod q$ (distribute $s^{-1}$). $k = H \\cdot w + S_k K \\cdot w \\mod q$ ($w = s^{-1}$). $g^k = g^{H \\cdot w + S_k K \\cdot w \\mod q}$ (put $g$ in both sides). $g^k = g^{H \\cdot w \\mod q} \\cdot g^{S_k K \\cdot w \\mod q}$ (product of the exponents). $g^k = g^{H \\cdot w \\mod q} \\cdot P^{K \\cdot w \\mod q}_k$ ($P_k = g^{S_k}$). $g^k = g^{u_1} \\cdot P^{u_2}_k$ (replace $u_1$ and $u_2$). $K = K^*$ (replace $K$ and $K^*$). There you go. This attest that the signature is correct and the message was signed by the owner of the private key.\nSchnorr Schnorr signature algorithm is a very similar algorithm to DSA. It was proposed by Claus-Peter Schnorr in 1989. It is considered to be more secure than DSA and is also more efficient. The patent for Schnorr signatures expired in 2008, just in time for Satoshi to include it in Bitcoin. However, it was probably not included due to the fact that there wasn’t good battle-tested software implementations of it at the time. However, it was added to Bitcoin in the Taproot upgrade7.\nSchnorr is a marvelous algorithm. It is so much simpler than DSA. Here’s how you sign a message using Schnorr:\nChoose a prime number $p$. Choose your private key $S_k$ as a random integer $\\in [1, p-1]$. Choose a generator $g$. Compute your public key $P_k$: $g^{S_k}$. Choose your nonce $k$: as a random integer $\\in [1, p-1]$. Compute your “public nonce” $K$: $g^k \\mod p$ (also known as $r$). Get your message ($m$) through a cryptographic hash function $H$ concatenating with $K$: $e = H(K || m)$. Compute your signature $s$: $k - S_k e$. Send to your buddy $(p, g)$, $P_k$, and $(K, s)$. And here’s how you can verify the signature:\nCompute $e = H(K || m)$. Compute $K^* = g^s P_k^e$. Compute $e^* = H(K^* || m)$. Assert $e = e^*$. How this works? Let’s go through a proof of correctness. As before, I added some comments to every operation in parentheses to make it easier to follow.\n$K^* = g^s P_k^e$ ($\\mod p$ implicit). $K^* = g^{k - S_k e} g^{S_k e}$ ($s = k - S_k e$ and $P_k = g^{S_k}$). $K^* = g^k$ (cancel $S_k e$ in the exponent of $g$). $K^* = K$ ($K = g^k$). Hence $H(K^* || m) = H(K || m)$. There you go. This attest that the signature is correct and the message was signed by the owner of the private key.\nWhy we don’t reuse nonces? Never, ever, reuse a nonce. Why? First, because nonce is short for “number used once”. It is supposed to be used only once. Because if you reuse a nonce, then you are pretty much screwed. An attacker can derive your private key from two signatures with the same nonce. This is called the “nonce reuse attack”.\nFun fact: this is what happened to the PlayStation 3.\nLet’s see how we can derive the private key from two signatures with the same nonce. Here we are in a context that we have two signatures $s$ and $s^\\prime$, both using the same nonce $k = k^\\prime$.\nFirst, let’s do the ugly DSA math:\n$$ \\begin{aligned} s^\\prime - s \u0026= (k^{\\prime {-1}} (H(m_1) + S_k K’)) - (k^{-1} (H(m_2) + S_k K)) \\\\ s^\\prime - s \u0026= k^{-1} (H(m_1) - H(m_2)) \\\\ k \u0026= (H(m_1) - H(m_2)) (s^\\prime - s)^{-1} \\end{aligned} $$\nNow remember you know $s$, $s^\\prime$, $H(m_1)$, $H(m_2)$ $K$, and $K^\\prime$. Let’s do the final step and solve for $S_k$:\n$$S_k = K^{-1} (k s - H(m_1))$$\nNow let’s do the Schnorr math. But in Schnorr, everything is simpler. Even nonce reuse attacks.\n$$s^\\prime - s = (k^\\prime - k) - S_k (e^\\prime - e)$$\nIf $k^\\prime = k$ (nonce reuse) then you can easily isolate $S_k$ with simple algebra.\nRemember: you know $s^\\prime, s, e, e^\\prime$ and $k^\\prime - k = 0$.\nWhy we can combine Schnorr Signatures and not DSA? In Bitcoin, we can combine Schnorr signatures and not DSA. Why? Because Schnorr signatures are linear. This means that you can add two Schnorr signatures and get a valid signature for the sum of the messages. This is not possible with DSA. This is called the “linearity property” of Schnorr signatures.\nRemember that in $Z_p$ addition, multiplication, and exponentiation, i.e anything with $+, \\cdot, -$, are linear operations However, division (modular inverse), .i.e anything that is $^{-1}$, is not linear. That is:\n$$x^{-1} + y^{-1} \\ne (x + y)^{-1}.$$\nHere’s a trivial python code that shows that modular inverse is not linear:\n\u003e\u003e\u003e p = 71; x = 13; y = 17; \u003e\u003e\u003e pow(x, -1, p) + pow(y, -1, p) == pow(x + y, -1, p) False Let’s revisit the signature step of DSA and Schnorr:\nDSA: $s = k^{-1} (H(m) + S_k K)$ Schnorr: $s = k - S_k H(K || m)$ So if you have two Schnorr signatures $s_1$ and $s_2$ for two messages $m_1$ and $m_2$, then you can easily compute a valid signature for the sum of the messages $m_1 + m_2$:\n$$s = s_1 + s_2$$\nAlso note that we can combine Schnorr public keys:\n$$P^\\prime_k + P_k = g^{S^\\prime_k} + g^{S_k} = g^{S_k^\\prime + S_k}$$\nAnd the signature $s$ for the sum of the messages $m_1 + m_2$ can be verified with the public key $P^\\prime_k + P_k$.\nThis is not possible with DSA.\nBecause the signature step in DSA is not linear, it has a $k^{-1}$ in it.\nTechnical Interlude: Elliptic Curves Technically speaking, Bitcoin uses the Elliptic Curve Digital Signature Algorithm (ECDSA), and the Schnorr signature algorithm is based on the same elliptic curve (EC) as ECDSA.\nAnd trivially speaking EC public-key cryptography in the end is just a finite field on $\\mathbb{Z}_p$. It has everything that we’ve seen so far:\nAddition Subtraction Multiplication Division Exponentiation Generators Discrete Logarithm Problem Conclusion I hope you enjoyed this companion post to the cryptography workshop. Remember don’t reuse nonces.\nLicense This post is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nthe image of a function $f$ is the set of all values that $f$ may produce. ↩︎\nthe problem of factoring a number into its prime factors is not known to be in the class of problems that can be solved in polynomial time, P. It is not known to be NP-complete, NP, either. Actually to find it P is NP or not is the hardest way to earn a million dollars, the P vs NP problem. ↩︎\nthis is called surjection. ↩︎\nat least $\\frac{1}{N}$ where $N$ is the size of $Y$. ↩︎\nactually this is not true. Due to the birthday paradox, the probability of finding a collision is not $\\frac{1}{N}$ but $\\frac{1}{\\sqrt{N}}$. Hence the search space is actually $2^{\\frac{N}{2}}$ instead of the original $2^N$. ↩︎\nThe answer is $x = 6$. This means that $3^6 = 15 \\mod 17$. ↩︎\nTaproot is a proposed Bitcoin protocol upgrade that was deployed as a forward-compatible soft fork. The validation of Taproot is based on Schnorr signatures. You can find more in BIPS 340, 341, and 342. ↩︎\n","wordCount":"3903","inLanguage":"en","datePublished":"2024-02-05T18:53:28-03:00","dateModified":"2024-04-15T09:24:31-03:00","author":{"@type":"Person","name":"Jose Storopoli"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://storopoli.io/2024-02-05-crypto-basics/"},"publisher":{"@type":"Organization","name":"Jose Storopoli, PhD","logo":{"@type":"ImageObject","url":"https://storopoli.io/assets/favicon.svg"}}}</script></head><body class=dark id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://storopoli.io/ accesskey=h title="Jose Storopoli, PhD (Alt + H)">Jose Storopoli, PhD</a><div class=logo-switches><button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://storopoli.io/about/ title=About><span>About</span></a></li><li><a href=https://storopoli.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://storopoli.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://storopoli.io/>Home</a>&nbsp;»&nbsp;<a href=https://storopoli.io/posts/>Blog</a></div><h1 class="post-title entry-hint-parent">Cryptography Basics</h1><div class=post-meta><span title='2024-02-05 18:53:28 -0300 -0300'>February 5, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Jose Storopoli&nbsp;|&nbsp;<a href=https://github.com/storopoli/storopoli.github.io/blob/main/content/posts/2024-02-05-crypto-basics/index.md rel="noopener noreferrer">Source code</a></div><div class=post-meta><span title="2024-04-15 09:24:31 -0300 -0300"><i>Last updated on April 15, 2024</i></span></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#one-way-functions aria-label="One-way functions">One-way functions</a></li><li><a href=#hash-functions aria-label="Hash Functions">Hash Functions</a><ul><li><a href=#sha-2-and-its-variants aria-label="SHA-2 and its variants">SHA-2 and its variants</a></li></ul></li><li><a href=#fields aria-label=Fields>Fields</a><ul><li><a href=#finite-fields aria-label="Finite Fields">Finite Fields</a><ul><li><a href=#operations-in-finite-fields aria-label="Operations in Finite Fields">Operations in Finite Fields</a></li><li><a href=#why-the-discrete-logarithm-problem-is-hard-as-fuck aria-label="Why the Discrete Logarithm Problem is Hard as Fuck">Why the Discrete Logarithm Problem is Hard as Fuck</a></li><li><a href=#numerical-example-of-the-discrete-logarithm-problem aria-label="Numerical Example of the Discrete Logarithm Problem">Numerical Example of the Discrete Logarithm Problem</a></li></ul></li></ul></li><li><a href=#public-key-cryptography aria-label="Public-key cryptography">Public-key cryptography</a></li><li><a href=#dsa aria-label=DSA>DSA</a></li><li><a href=#schnorr aria-label=Schnorr>Schnorr</a></li><li><a href=#why-we-dont-reuse-nonces aria-label="Why we don&rsquo;t reuse nonces?">Why we don&rsquo;t reuse nonces?</a></li><li><a href=#why-we-can-combine-schnorr-signatures-and-not-dsa aria-label="Why we can combine Schnorr Signatures and not DSA?">Why we can combine Schnorr Signatures and not DSA?</a></li><li><a href=#technical-interlude-elliptic-curves aria-label="Technical Interlude: Elliptic Curves">Technical Interlude: Elliptic Curves</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#license aria-label=License>License</a></li></ul></div></details></div><div class=post-content><figure><img loading=lazy src=euclid.webp alt="Euclid's one-way function"><figcaption><p>Euclid&rsquo;s one-way function</p></figcaption></figure><blockquote><p>Warning: This post has <a href=https://katex.org/>KaTeX</a> enabled,
so if you want to view the rendered math formulas,
you&rsquo;ll have to unfortunately enable JavaScript.</p></blockquote><p>This is the companion post to the <a href=https://github.com/storopoli/cryptography-workshop>cryptography workshop</a>
that I gave at a local BitDevs.
Let&rsquo;s explore the basics of cryptography.
We&rsquo;ll go through the following topics:</p><ul><li>One-way functions</li><li>Hash functions</li><li>Public-key cryptography</li><li>DSA</li><li>Schnorr</li><li>Why we don&rsquo;t reuse nonces?</li><li>Why we can combine Schnorr Signatures and not DSA?</li></ul><h2 id=one-way-functions>One-way functions<a hidden class=anchor aria-hidden=true href=#one-way-functions>#</a></h2><p>A one-way function is a <strong>function that is easy to compute on every input,
but hard to invert given the image<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> of a random input</strong>.
For example, imagine an omelet.
It&rsquo;s easy to make an omelet from eggs,
but it&rsquo;s hard to make eggs from an omelet.
In a sense we can say that the function $\text{omelet}$ is a one-way function</p><p>$$\text{omelet}^{-1}(x) = \ldots$$</p><p>That is, we don&rsquo;t know how to invert the function $\text{omelet}$ to get the original eggs back.
Or, even better, <strong>the benefit we get from reverting the omelet to eggs is not worth the effort,
either in time or money</strong>.</p><p>Not all functions are one-way functions.
The exponential function, $f(x) = e^x$, is not a one-way function.
It is easy to undo the exponential function by taking the natural logarithm,</p><p>$$f^{-1}(x) = \ln(x)$$</p><p>To showcase one-way functions, let&rsquo;s take a look at the following example.
Let&rsquo;s play around with some numbers.
Not any kind of numbers, but very special numbers called <strong>primes</strong>.
A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.</p><p>If I give you a big number $n$ and ask you to find its prime factors,
and point a gun at your head,
you&rsquo;ll pretty much screwed.
There&rsquo;s no known efficient algorithm<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> to factorize a big number into its prime factors.
You&rsquo;ll be forced to test all numbers from 2 to $\sqrt{n}$ to see if they divide $n$.</p><p>Here&rsquo;s a number:</p><p>$$90809$$</p><p>What are its prime factors?
It&rsquo;s $1279 \cdot 71$.
Easy to check, right?
Hard to find.
That&rsquo;s because prime factorization, if you choose a fucking big number, is a one-way function.</p><h2 id=hash-functions>Hash Functions<a hidden class=anchor aria-hidden=true href=#hash-functions>#</a></h2><p>Let&rsquo;s spice things up.
There is a special class of one-way functions called <strong>hash functions</strong>.</p><p><strong>A hash function is any function that can be used to map data of arbitrary size to fixed-size values</strong>.</p><p>But we are most interested in <strong><em>cryptographic</em> hash functions</strong>,
which are hash functions that have statistical properties desirable for cryptographic application:</p><ul><li><strong>One-way function</strong>: easy to compute $y = f(x)$, hard as fuck to do the opposite, $x = f^{-1}(y)$.</li><li><strong>Deterministic</strong>: given a function that maps elements from set $X$ to set $Y$, $f: X \to Y$,
for every $x \in X$ there&rsquo;s <em>at least one</em> $y \in Y$<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.
This means that if I give you a certain input, it will always map to the same output.
It is deterministic.</li><li><strong>Collision resistance</strong>: the possible values of $f: X \to Y$ follows a uniform distribution,
that is, given the size of the set $Y$,
it is hard to find two $x_1, x_2 \in X$ that have the same $y \in Y$ value<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.
This property is really important because if an attacker wants to brute-force the
hash function, there&rsquo;s no option than searching uniformly across the whole possible
space of possible values that the hash function outputs<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</li></ul><p>These properties make enable cryptographic hash functions to be used in a wide range of applications,
including but not limited to:</p><ul><li><p><strong>Digital signatures</strong>: Hash functions are used to create a digest of the message to be signed.
The digital signature is then generated using the hash, rather than the message itself,
to ensure integrity and non-repudiation.</p></li><li><p><strong>Password hashing</strong>: Storing passwords as hash values instead of plain text.
Even if the hash values are exposed,
the original passwords remain secure due to the pre-image resistance property.</p></li><li><p><strong>Blockchain and cryptocurrency</strong>: Hash functions are used to maintain the integrity of the blockchain.
Each block contains the hash of the previous block, creating a secure link.
Cryptographic hashes also underpin various aspects of cryptocurrency transactions.</p></li><li><p><strong>Data integrity verification</strong>: Hash functions are used to ensure that files, messages,
or data blocks have not been altered.
By comparing hash values computed before and after transmission or storage,
any changes in the data can be detected.</p></li></ul><p>We&rsquo;ll cover just the <strong>digital signatures</strong> part in this post.</p><h3 id=sha-2-and-its-variants>SHA-2 and its variants<a hidden class=anchor aria-hidden=true href=#sha-2-and-its-variants>#</a></h3><p>The Secure Hash Algorithm 2 (SHA-2) is a set of cryptographic hash functions designed by the National Security Agency (NSA).
It was first published in 2001.</p><p>It is composed of six hash functions with digests that are 224, 256, 384, 512, 512/224, and 512/256 bits long:</p><ul><li><code>SHA-224</code></li><li><code>SHA-256</code></li><li><code>SHA-384</code></li><li><code>SHA-512</code></li><li><code>SHA-512/224</code></li><li><code>SHA-512/256</code></li></ul><p>Amongst these, let&rsquo;s focus on SHA-256, which is the most widely used while also being notoriously adopted by bitcoin.</p><p>SHA-256 does not have any known vulnerabilities and is considered secure.
It comprises of 32-bit words and operates on 64-byte blocks.
The algorithm does 64 rounds of the following operations:</p><ul><li><code>AND</code>: bitwise boolean AND</li><li><code>XOR</code>: bitwise boolean XOR</li><li><code>OR</code>: bitwise boolean OR</li><li><code>ROT</code>: right rotation bit shift</li><li><code>ADD</code>: addition modulo $2^{32}$</li></ul><p>You can check <a href=https://en.wikipedia.org/wiki/SHA-2#Pseudocode>SHA-256 Pseudocode on Wikipedia</a>.
It really scrambles the input message in a way that is very hard to reverse.</p><p>These operations are non-linear and very difficult to keep track of.
In other words, you can&rsquo;t reverse-engineer the hash to find the original message.
There&rsquo;s no <a href=https://en.wikipedia.org/wiki/Automatic_differentiation>&ldquo;autodiff&rdquo;</a> for hash functions.</p><p>Since it is a cryptographic hash function,
if we change just one bit of the input,
the output will be completely different.
Check this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;The quick brown fox jumps over the lazy dog&#34;</span> <span class=p>|</span> shasum -a <span class=m>256</span>
</span></span><span class=line><span class=cl>c03905fcdab297513a620ec81ed46ca44ddb62d41cbbd83eb4a5a3592be26a69  -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;The quick brown fox jumps over the lazy dog.&#34;</span> <span class=p>|</span> shasum -a <span class=m>256</span>
</span></span><span class=line><span class=cl>b47cc0f104b62d4c7c30bcd68fd8e67613e287dc4ad8c310ef10cbadea9c4380  -
</span></span></code></pre></div><p>Here we are only adding a period at the end of the sentence,
and the hash is completely different.
This is due to the property of collision resistance that we mentioned earlier.</p><h2 id=fields>Fields<a hidden class=anchor aria-hidden=true href=#fields>#</a></h2><p>Before we dive into public-key cryptography,
we need a brief interlude on fields.</p><p><strong><a href=https://en.wikipedia.org/wiki/Field_(mathematics)>Fields</a> are sets with two binary operations,
called addition $+$ and multiplication $\times$</strong>.
We write</p><p>$$F = (F, +, \times)$$</p><p>to denote a field,
where $F$ is the set, $+$ is the addition operation,
and $\times$ is the multiplication operation.</p><p>Addition and multiplication behave similar to the addition and multiplication of real numbers.
For example, addition is <strong>commutative</strong> and <strong>associative</strong></p><p>$$a + b = b + a,$$</p><p>and multiplication is <strong>distributive</strong></p><p>$$a \times (b + c) = a \times b + a \times c.$$</p><p>Also, there are two special elements in the field,
called the <strong>additive identity</strong> $-a$ and the <strong>multiplicative identity</strong> $a^{-1}$,
such that</p><p>$$a + (-a) = I,$$</p><p>and</p><p>$$a \times a^{-1} = I,$$</p><p>where $I$ is the identity element.</p><p>Note that this allows us to define <strong>subtraction</strong></p><p>$$a - b = a + (-b),$$</p><p>and <strong>division</strong></p><p>$$a \div b = a \times b^{-1}.$$</p><h3 id=finite-fields>Finite Fields<a hidden class=anchor aria-hidden=true href=#finite-fields>#</a></h3><p>Now we are ready for finite fields.
A <a href=https://en.wikipedia.org/wiki/Finite_field><em>finite field</em></a>, also called a Galois field (in honor of Évariste Galois),
is a <strong>field with a finite number of elements.
As with any field, a finite field is a set on which the operations of multiplication,
addition, subtraction and division are defined and satisfy the rules above for fields</strong>.</p><p>Finite fields is a very rich topic in mathematics,
and there are many ways to construct them.
The easiest way to construct a finite field is to take the <strong>integers modulo a prime number $p$</strong>.
For example $\mathbb{Z}_5$ is a finite field with 5 elements:</p><p>$$\mathbb{Z}_5 = \lbrace 0, 1, 2, 3, 4 \rbrace.$$</p><p>In general, $\mathbb{Z}_n$ is a finite field with $n$ elements:</p><p>$$\mathbb{Z}_n = \lbrace 0, 1, 2, \ldots, n - 1 \rbrace.$$</p><p><strong>The number of elements in a finite field is called the <em>order</em> of the field</strong>.
The order of a finite field is <strong>always a prime number $p$</strong>.
The $\mathbb{Z}_5$ example above is a finite field of order 5.
However, $\mathbb{Z}_4$ is not a finite field,
because 4 is not a prime number, but rather a composite number.</p><p>$$4 = 2 \times 2.$$</p><p>And we can write $\mathbb{Z}_4$ as</p><p>$$\mathbb{Z}_4 = 2 \times \mathbb{Z}_2.$$</p><p>This means that every element in $a \in \mathbb{Z}_4$ can be written as</p><p>$$a = 2 \times b,$$</p><p>where $b$ is an element in $\mathbb{Z}_2$.</p><p>Hence, not every element of $\mathbb{Z}_4$ is unique, and they are equivalent to the elements in $\mathbb{Z}_2$.</p><p>In general if $n$ is a composite number,
then $\mathbb{Z}_n$ is not a finite field.
However, if $n = r \times s$ where $r$ and $s$ are prime numbers,
and $r &lt; s$,
then $\mathbb{Z}_n$ is a finite field of order $r$.</p><h4 id=operations-in-finite-fields>Operations in Finite Fields<a hidden class=anchor aria-hidden=true href=#operations-in-finite-fields>#</a></h4><p><strong>Addition</strong> in finite fields is defined as the remainder of the sum of two elements modulo the order of the
field.</p><p>For example, in $\mathbb{Z}_3$,</p><p>$$1 + 2 = 3 \mod 3 = 0.$$</p><p>We can also define subtraction in finite fields as the remainder of the difference of two elements modulo the order of the field.</p><p>For example, in $\mathbb{Z}_3$,</p><p>$$1 - 2 = -1 \mod 3 = 2.$$</p><p>Multiplication in finite fields can be written as multiple additions.
For example, in $\mathbb{Z}_3$,</p><p>$$2 \times 2 = 2 + 2 = 4 \mod 3 = 1.$$</p><p>Exponentiation in finite fields can be written as multiple multiplications.
For example, in $\mathbb{Z}_3$,</p><p>$$2^2 = 2 \times 2 = 4 \mod 3 = 1.$$</p><p>As you can see addition, subtraction, and multiplication becomes linear operations.
This is very trivial for any finite field.</p><p>However, for division we are pretty much screwed.
It is really hard to find the multiplicative inverse of an element in a finite field.
For example, suppose that we have numbers $a,b$ in a very large finite field $\mathbb{Z}_p$,
such that</p><p>$$c = a \times b \mod p.$$</p><p>Then we can write division as</p><p>$$a = c \div b = c \times b^{-1} \mod p.$$</p><p>Now we need to find $b^{-1}$, which is the multiplicative inverse of $b$.
This is called the <a href=https://en.wikipedia.org/wiki/Discrete_logarithm><strong><em>discrete logarithm problem</em></strong></a>.
Because we need to find $b^{-1}$ such that</p><p>$$b^{-1} = \log_b c \mod p.$$</p><p>Since this number is a discrete number and not a real number,
that&rsquo;s why it&rsquo;s called the discrete logarithm problem.</p><p>Good luck my friend, no efficient method is known for computing them in general.
You can try brute force, but that&rsquo;s not efficient.</p><h4 id=why-the-discrete-logarithm-problem-is-hard-as-fuck>Why the Discrete Logarithm Problem is Hard as Fuck<a hidden class=anchor aria-hidden=true href=#why-the-discrete-logarithm-problem-is-hard-as-fuck>#</a></h4><p>To get a feeling why the discrete logarithm problem is difficult,
let&rsquo;s add one more concept to our bag of knowledge.
Every finite field has <em><strong>generators</strong></em>,
also known as <em><strong>primitive roots</strong></em>,
which is also a member of the group,
such that applying multiplication to this one single element
makes possible to generate the whole finite field.</p><p>Let&rsquo;s illustrate this with an example.
Below we have a table of all the results of the following operation</p><p>$$b^x \mod 7$$</p><p>for every possible value of $x$.
As you&rsquo;ve guessed right this is the $\mathbb{Z}_7$ finite field.</p><table><thead><tr><th style=text-align:center>$b$</th><th style=text-align:center>$b^1 \mod 7$</th><th style=text-align:center>$b^2 \mod 7$</th><th style=text-align:center>$b^3 \mod 7$</th><th style=text-align:center>$b^4 \mod 7$</th><th style=text-align:center>$b^5 \mod 7$</th><th style=text-align:center>$b^6 \mod 7$</th></tr></thead><tbody><tr><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td></tr><tr><td style=text-align:center>$2$</td><td style=text-align:center>$2$</td><td style=text-align:center>$4$</td><td style=text-align:center>$1$</td><td style=text-align:center>$2$</td><td style=text-align:center>$4$</td><td style=text-align:center>$1$</td></tr><tr><td style=text-align:center>$3$</td><td style=text-align:center>$3$</td><td style=text-align:center>$2$</td><td style=text-align:center>$6$</td><td style=text-align:center>$4$</td><td style=text-align:center>$5$</td><td style=text-align:center>$1$</td></tr><tr><td style=text-align:center>$4$</td><td style=text-align:center>$4$</td><td style=text-align:center>$2$</td><td style=text-align:center>$1$</td><td style=text-align:center>$4$</td><td style=text-align:center>$2$</td><td style=text-align:center>$1$</td></tr><tr><td style=text-align:center>$5$</td><td style=text-align:center>$5$</td><td style=text-align:center>$4$</td><td style=text-align:center>$6$</td><td style=text-align:center>$2$</td><td style=text-align:center>$3$</td><td style=text-align:center>$1$</td></tr><tr><td style=text-align:center>$6$</td><td style=text-align:center>$6$</td><td style=text-align:center>$1$</td><td style=text-align:center>$6$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td><td style=text-align:center>$1$</td></tr></tbody></table><p>You see that something interesting is happening here.
For specific values of $b$, such as $b = 3$, and $b = 5$, we are able to <strong>generate the whole finite field</strong>.
Hence, say that $3$ and $5$ are <em><strong>generators</strong></em> or <em><strong>primitive roots</strong></em> of $\mathbb{Z}_7$.</p><p>Now suppose I ask you to find $x$ in the following equation</p><p>$$3^x \mod p = 11$$</p><p>where $p$ is a very large prime number.
Then you don&rsquo;t have any other option than brute forcing it.
<strong>You&rsquo;ll need to try each exponent $x \in \mathbb{Z}_p$ until you find the one that satisfies the equation</strong>.</p><p>Notice that this operation is very asymmetric.
It is very easy to compute $3^x \mod p$ for any $x$,
but it is very hard to find $x$ given $3^x \mod p$.</p><p>Now we are ready to dive into public-key cryptography.</p><h4 id=numerical-example-of-the-discrete-logarithm-problem>Numerical Example of the Discrete Logarithm Problem<a hidden class=anchor aria-hidden=true href=#numerical-example-of-the-discrete-logarithm-problem>#</a></h4><p>Let&rsquo;s illustrate the discrete logarithm problem with a numerical example.</p><ol><li><strong>Choose a prime number $p$</strong>. Let&rsquo;s pick $p = 17$.</li><li><strong>Choose a generator $g$ of the group</strong>.
For $p = 17$, we can choose $g = 3$ because $3$ is a primitive root of $\mathbb{Z}_{17}$.</li><li><strong>Choose an element $x$</strong>.
Let&rsquo;s pick $x = 15$.</li></ol><p>The discrete logarithm problem is to find $x$ given $g^x \mod p$.
So let&rsquo;s plug in the numbers; find $x$ in</p><p>$$3^x = 15 \mod 17 $$</p><p>Try to find it.
Good luck<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>.</p><h2 id=public-key-cryptography>Public-key cryptography<a hidden class=anchor aria-hidden=true href=#public-key-cryptography>#</a></h2><p>Public-key cryptography, or asymmetric cryptography, is a cryptographic system that uses pairs of keys:
private and public.
The public key you can share with anyone,
but the private key you must keep secret.
The keys are related mathematically,
but it is computationally infeasible to derive the private key from the public key.
In other words, the public key is a one-way function of the private key.</p><p>Before we dive into the details of the public-key cryptography, and signing and verifying messages,
let me introduce some notation:</p><ul><li>$p$: big fucking huge prime number (4096 bits or more)</li><li>$\mathbb{Z}_p$: the finite field of order $p$</li><li>$g$: a generator of $\mathbb{Z}_p$</li><li>$S_k$: secret key, a random integer in the finite field $\mathbb{Z}_p$</li><li>$P_k$: public key derived by $P_k = g^{S_k}$</li></ul><p>If you know $S_k$ and $g$ (which is almost always part of the spec),
then it&rsquo;s easy to derive the $P_k$.
However, if you only know $g$ and $P_k$, good luck finding $S_k$.
It&rsquo;s the discrete log problem again.
And as long $p$ is HUGE you are pretty confident that no one will find your secret key
from your public key.</p><p>Now what we can do with these keys and big prime numbers?
We&rsquo;ll we can sign a message with our secret key and everyone can verify the authenticity of
the message using our public key.
The message in our case it is commonly a hash function of the &ldquo;original message&rdquo;.
Due to the collision resistance property, we can definitely assert that:</p><ol><li>the message has not been altered</li><li>the message was signed by the owner of the private key</li></ol><p>Fun fact, I once gave a recommendation letter to a very bright student,
that was only a plain text file signed with my private key.
I could rest assured that the letter was not altered,
and the student and other people could verify that I was the author of the letter.</p><p>Next, we&rsquo;ll dive into the details of the Digital Signature Algorithm (DSA)
and the Schnorr signature algorithm.</p><h2 id=dsa>DSA<a hidden class=anchor aria-hidden=true href=#dsa>#</a></h2><p>DSA stands for <a href=https://en.wikipedia.org/wiki/Digital_Signature_Algorithm>Digital Signature Algorithm</a>.
It was first proposed by the National Institute of Standards and Technology (NIST) in 1991.
Note that <a href=https://lwn.net/Articles/958048/>OpenSSH announced that DSA is scheduled for removal in 2025</a>.</p><p>Here&rsquo;s how you can sign a message using DSA:</p><ol><li>Choose two prime numbers $p, q$ such that $p - 1 \mod q = 0$ (e.g., 1279 and 71).</li><li>Choose your private key $S_k$ as a random integer $\in [1, q-1]$.</li><li>Choose a generator $g$.</li><li>Compute your public key $P_k$: $g^{S_k} \mod p$.</li><li>Choose your nonce $k$: as a random integer $\in [1, q-1]$.</li><li>Compute your &ldquo;public nonce&rdquo; $K$: $(g^k \mod p) \mod q$ (also known as $r$).</li><li>Get your message ($m$) through a cryptographic hash function $H$: $H(m)$.</li><li>Compute your signature $s$: $(k^{-1} (H(m) + S_k K)) \mod q$.</li><li>Send to your buddy $(p, q, g)$, $P_k$, and $(K, s)$.</li></ol><p>And here&rsquo;s how you can verify the signature:</p><ol><li>Compute $w = s^{-1} \mod q$.</li><li>Compute $u_1 = H{m} \cdot w \mod q$.</li><li>Compute $u_2 = K \cdot w \mod q$.</li><li>Compute $K^* = {g^{u_1} P^{u_2}_k \mod p} \mod q$.</li><li>Assert $K = K^*$.</li></ol><p>How this works?
Let&rsquo;s go through a proof of correctness.
I added some comments to every operation in parentheses to make it easier to follow.</p><ol><li>$s = k^{-1} \cdot {H + S_k K} \mod q$ ($\mod p$ and $H(m)$ implicit).</li><li>$k = s^{-1} \cdot {H + S_k K} \mod q$ (move $s$ to $k$).</li><li>$k = H \cdot s^{-1} + S_k K \cdot s^{-1} \mod q$ (distribute $s^{-1}$).</li><li>$k = H \cdot w + S_k K \cdot w \mod q$ ($w = s^{-1}$).</li><li>$g^k = g^{H \cdot w + S_k K \cdot w \mod q}$ (put $g$ in both sides).</li><li>$g^k = g^{H \cdot w \mod q} \cdot g^{S_k K \cdot w \mod q}$ (product of the exponents).</li><li>$g^k = g^{H \cdot w \mod q} \cdot P^{K \cdot w \mod q}_k$ ($P_k = g^{S_k}$).</li><li>$g^k = g^{u_1} \cdot P^{u_2}_k$ (replace $u_1$ and $u_2$).</li><li>$K = K^*$ (replace $K$ and $K^*$).</li></ol><p>There you go.
This attest that the signature is correct and the message was signed by the owner of the private key.</p><h2 id=schnorr>Schnorr<a hidden class=anchor aria-hidden=true href=#schnorr>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Schnorr_signature>Schnorr signature algorithm</a>
is a very similar algorithm to DSA.
It was proposed by Claus-Peter Schnorr in 1989.
It is considered to be more secure than DSA and is also more efficient.
The patent for Schnorr signatures expired in 2008,
just in time for Satoshi to include it in Bitcoin.
However, it was probably not included due to the fact that there wasn&rsquo;t
good battle-tested software implementations of it at the time.
However, it was added to Bitcoin in the Taproot upgrade<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>.</p><p>Schnorr is a marvelous algorithm.
It is so much simpler than DSA.
Here&rsquo;s how you sign a message using Schnorr:</p><ol><li>Choose a prime number $p$.</li><li>Choose your private key $S_k$ as a random integer $\in [1, p-1]$.</li><li>Choose a generator $g$.</li><li>Compute your public key $P_k$: $g^{S_k}$.</li><li>Choose your nonce $k$: as a random integer $\in [1, p-1]$.</li><li>Compute your &ldquo;public nonce&rdquo; $K$: $g^k \mod p$ (also known as $r$).</li><li>Get your message ($m$) through a cryptographic hash function $H$ concatenating with $K$: $e = H(K || m)$.</li><li>Compute your signature $s$: $k - S_k e$.</li><li>Send to your buddy $(p, g)$, $P_k$, and $(K, s)$.</li></ol><p>And here&rsquo;s how you can verify the signature:</p><ol><li>Compute $e = H(K || m)$.</li><li>Compute $K^* = g^s P_k^e$.</li><li>Compute $e^* = H(K^* || m)$.</li><li>Assert $e = e^*$.</li></ol><p>How this works?
Let&rsquo;s go through a proof of correctness.
As before, I added some comments to every operation in parentheses to make it easier to follow.</p><ol><li>$K^* = g^s P_k^e$ ($\mod p$ implicit).</li><li>$K^* = g^{k - S_k e} g^{S_k e}$ ($s = k - S_k e$ and $P_k = g^{S_k}$).</li><li>$K^* = g^k$ (cancel $S_k e$ in the exponent of $g$).</li><li>$K^* = K$ ($K = g^k$).</li><li>Hence $H(K^* || m) = H(K || m)$.</li></ol><p>There you go.
This attest that the signature is correct and the message was signed by the owner of the private key.</p><h2 id=why-we-dont-reuse-nonces>Why we don&rsquo;t reuse nonces?<a hidden class=anchor aria-hidden=true href=#why-we-dont-reuse-nonces>#</a></h2><p>Never, ever, reuse a nonce.
Why?
First, because nonce is short for &ldquo;number used once&rdquo;.
It is supposed to be used only once.
Because if you reuse a nonce, then you are pretty much screwed.
An attacker can derive your private key from two signatures with the same nonce.
This is called the &ldquo;nonce reuse attack&rdquo;.</p><p>Fun fact: this is what happened to the
<a href=https://en.wikipedia.org/wiki/PlayStation_3_homebrew#Private_key_compromised>PlayStation 3</a>.</p><p>Let&rsquo;s see how we can derive the private key from two signatures with the same nonce.
Here we are in a context that we have two signatures $s$ and $s^\prime$,
both using the same nonce $k = k^\prime$.</p><p>First, let&rsquo;s do the <del>ugly</del> DSA math:</p><p>$$
\begin{aligned}
s^\prime - s &= (k^{\prime {-1}} (H(m_1) + S_k K&rsquo;)) - (k^{-1} (H(m_2) + S_k K)) \\
s^\prime - s &= k^{-1} (H(m_1) - H(m_2)) \\
k &= (H(m_1) - H(m_2)) (s^\prime - s)^{-1}
\end{aligned}
$$</p><p>Now remember you know $s$, $s^\prime$, $H(m_1)$, $H(m_2)$ $K$, and $K^\prime$.
Let&rsquo;s do the final step and solve for $S_k$:</p><p>$$S_k = K^{-1} (k s - H(m_1))$$</p><p>Now let&rsquo;s do the Schnorr math.
But in Schnorr, everything is simpler.
Even nonce reuse attacks.</p><p>$$s^\prime - s = (k^\prime - k) - S_k (e^\prime - e)$$</p><p>If $k^\prime = k$ (nonce reuse) then you can easily isolate $S_k$ with simple algebra.</p><p>Remember: you know $s^\prime, s, e, e^\prime$ and $k^\prime - k = 0$.</p><h2 id=why-we-can-combine-schnorr-signatures-and-not-dsa>Why we can combine Schnorr Signatures and not DSA?<a hidden class=anchor aria-hidden=true href=#why-we-can-combine-schnorr-signatures-and-not-dsa>#</a></h2><p>In Bitcoin, we can combine Schnorr signatures and not DSA.
Why?
Because Schnorr signatures are linear.
This means that you can add two Schnorr signatures and get a valid signature for the sum of the messages.
This is not possible with DSA.
This is called the &ldquo;linearity property&rdquo; of Schnorr signatures.</p><p>Remember that in $Z_p$ addition, multiplication, and exponentiation,
i.e anything with $+, \cdot, -$, are linear operations
However, division (modular inverse),
.i.e anything that is $^{-1}$, is not linear.
That is:</p><p>$$x^{-1} + y^{-1} \ne (x + y)^{-1}.$$</p><p>Here&rsquo;s a trivial python code that shows that modular inverse is not linear:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>71</span><span class=p>;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>17</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>pow</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>+</span> <span class=nb>pow</span><span class=p>(</span><span class=n>y</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>==</span> <span class=nb>pow</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kc>False</span>
</span></span></code></pre></div><p>Let&rsquo;s revisit the signature step of DSA and Schnorr:</p><ul><li>DSA: $s = k^{-1} (H(m) + S_k K)$</li><li>Schnorr: $s = k - S_k H(K || m)$</li></ul><p>So if you have two Schnorr signatures $s_1$ and $s_2$ for two messages $m_1$ and $m_2$,
then you can easily compute a valid signature for the sum of the messages $m_1 + m_2$:</p><p>$$s = s_1 + s_2$$</p><p>Also note that we can combine Schnorr public keys:</p><p>$$P^\prime_k + P_k = g^{S^\prime_k} + g^{S_k} = g^{S_k^\prime + S_k}$$</p><p>And the signature $s$ for the sum of the messages $m_1 + m_2$
can be verified with the public key $P^\prime_k + P_k$.</p><p>This is not possible with DSA.</p><p>Because the signature step in DSA is not linear,
it has a $k^{-1}$ in it.</p><h2 id=technical-interlude-elliptic-curves>Technical Interlude: Elliptic Curves<a hidden class=anchor aria-hidden=true href=#technical-interlude-elliptic-curves>#</a></h2><p>Technically speaking, Bitcoin uses the Elliptic Curve Digital Signature Algorithm (ECDSA),
and the Schnorr signature algorithm is based on the same elliptic curve (EC) as ECDSA.</p><p>And trivially speaking EC public-key cryptography in the end is just a finite field
on $\mathbb{Z}_p$.
It has everything that we&rsquo;ve seen so far:</p><ul><li>Addition</li><li>Subtraction</li><li>Multiplication</li><li>Division</li><li>Exponentiation</li><li>Generators</li><li>Discrete Logarithm Problem</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope you enjoyed this companion post to the
<a href=https://github.com/storopoli/cryptography-workshop>cryptography workshop</a>.
Remember don&rsquo;t reuse nonces.</p><h2 id=license>License<a hidden class=anchor aria-hidden=true href=#license>#</a></h2><p>This post is licensed under <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a>.</p><p><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img loading=lazy src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt="CC BY-NC-SA 4.0"></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>the image of a function $f$ is the set of all values that $f$ may produce.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>the problem of factoring a number into its prime factors is not known to be in
the class of problems that can be solved in polynomial time, P.
It is not known to be NP-complete, NP, either.
Actually to find it P is NP or not is the hardest way to earn a million dollars,
<a href=https://en.m.wikipedia.org/wiki/Millennium_Prize_Problems#P_versus_NP>the P vs NP problem</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>this is called <a href=https://en.wikipedia.org/wiki/Bijection%2C_injection_and_surjection>surjection</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>at least $\frac{1}{N}$ where $N$ is the size of $Y$.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>actually this is not true. Due to the <a href=https://en.wikipedia.org/wiki/Birthday_problem#Probability_of_a_shared_birthday_(collision)>birthday paradox</a>,
the probability of finding a collision is not $\frac{1}{N}$ but $\frac{1}{\sqrt{N}}$.
Hence the search space is actually $2^{\frac{N}{2}}$ instead of the original $2^N$.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>The answer is $x = 6$. This means that $3^6 = 15 \mod 17$.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Taproot is a proposed Bitcoin protocol upgrade that was deployed
as a forward-compatible soft fork.
The validation of Taproot is based on Schnorr signatures.
You can find more in BIPS
<a href=https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>340</a>,
<a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>341</a>, and
<a href=https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki>342</a>.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://storopoli.io/tags/cryptography/>Cryptography</a></li><li><a href=https://storopoli.io/tags/bitcoin/>Bitcoin</a></li></ul><nav class=paginav><a class=next href=https://storopoli.io/2024-01-30-sudoku/><span class=title>Next »</span><br><span>Fullstack and Progressive Web Apps in Rust: A Tale of a Sudoku Spyware</span></a></nav></footer></article></main><footer class=footer><span><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>